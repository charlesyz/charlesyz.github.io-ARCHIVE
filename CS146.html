<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>Jan 8: Reasoning about programming</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body>
        <ul>
<li><a href="#jan-8-reasoning-about-programming">Jan 8: Reasoning about programming</a>
<ul>
<li><a href="#structural-recursion">Structural Recursion</a></li>
<li><a href="#accumulative-recursion">Accumulative Recursion</a></li>
<li><a href="#generative-recurion">Generative Recurion</a></li>
</ul>
</li>
<li><a href="#jan-10-impure-racket">Jan 10: Impure Racket</a>
<ul>
<li><a href="#reasoning-about-side-effects">Reasoning about side effects.</a></li>
<li><a href="#substitution-model">Substitution model</a></li>
<li><a href="#affecting-omega-in-racket">Affecting <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span> in Racket</a></li>
<li><a href="#reasoning-about-output-cont">Reasoning about output cont.</a></li>
</ul>
</li>
<li><a href="#jan-15-modelling-input">Jan 15: Modelling Input</a>
<ul>
<li><a href="#input-in-racket">Input in Racket</a></li>
<li><a href="#downsides-of-input">Downsides of Input</a></li>
</ul>
</li>
<li><a href="#jan-17-intro-to-c">Jan 17: Intro to C</a>
<ul>
<li><a href="#expressions">Expressions:</a></li>
<li><a href="#statements">Statements:</a></li>
<li><a href="#block">Block:</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#programs-a-sequence-of-functions">Programs: a sequence of functions</a></li>
<li><a href="#variables">Variables</a></li>
<li><a href="#characters">Characters</a></li>
<li><a href="#next-question">Next Question:</a></li>
<li><a href="#comma-operator">Comma Operator</a></li>
</ul>
</li>
<li><a href="#jan-24-mutation">Jan 24: Mutation</a>
<ul>
<li><a href="#mutation-in-racket">Mutation in Racket</a>
<ul>
<li><a href="#application-memoization">Application: Memoization</a></li>
</ul>
</li>
<li><a href="#mutation-in-c">Mutation in C:</a></li>
</ul>
</li>
<li><a href="#jan-29-repetition">Jan 29: Repetition</a>
<ul>
<li><a href="#while-loop">While Loop</a></li>
<li><a href="#for-loop">For Loop</a></li>
<li><a href="#updating-counters">Updating Counters</a></li>
<li><a href="#global-constants">Global Constants</a></li>
<li><a href="#intermediate-mutation-racket">Intermediate Mutation (Racket)</a></li>
</ul>
</li>
<li><a href="#jan-31-boxes">Jan 31: Boxes</a>
<ul>
<li><a href="#stepping-semantics">Stepping Semantics</a></li>
</ul>
</li>
<li><a href="#jan-5-pointersmutation-cont">Jan 5: Pointers/mutation Cont.</a>
<ul>
<li><a href="#better-mutation-in-racket">Better mutation in Racket</a>
<ul>
<li><a href="#semantics">Semantics</a></li>
</ul>
</li>
<li><a href="#define">Define</a></li>
<li><a href="#back-to-c">Back to c</a></li>
</ul>
</li>
<li><a href="#jan-7-memory-and-vectors">Jan 7: Memory and Vectors</a>
<ul>
<li><a href="#vectors">Vectors</a></li>
</ul>
</li>
<li><a href="#vectors-in-c-arrays">Vectors in C: Arrays</a></li>
<li><a href="#feb14-arrays-continued">Feb14: Arrays Continued</a>
<ul>
<li><a href="#pointer-arithmetic">Pointer Arithmetic</a></li>
</ul>
</li>
<li><a href="#feb-26-memory-model">Feb 26: Memory Model</a>
<ul>
<li><a href="#static">Static:</a></li>
<li><a href="#stack-area">Stack Area:</a></li>
<li><a href="#heap">Heap</a>
<ul>
<li><a href="#rackets-solution">Racket's Solution:</a></li>
<li><a href="#cs-solution">C's Solution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#missed-feb-27">Missed Feb 27</a></li>
<li><a href="#feb-28-adt">Feb 28 ADT</a>
<ul>
<li><a href="#racket">Racket</a></li>
<li><a href="#c">C</a></li>
</ul>
</li>
<li><a href="#march-5th-interpreting-mutation">March 5th: Interpreting Mutation</a></li>
<li><a href="#module-2-simp">Module 2: SIMP</a>
<ul>
<li><a href="#racket-macros">Racket Macros</a></li>
<li><a href="#semantics-1">Semantics</a></li>
<li><a href="#interpreter-haskell">Interpreter: Haskell</a>
<ul>
<li><a href="#adding-printing">Adding Printing:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#proofs-in-imperative-programs">Proofs in imperative Programs</a>
<ul>
<li><a href="#hoare-logic">Hoare Logic</a></li>
</ul>
</li>
<li><a href="#module-3-primp-primitive-imperative-language">Module 3: PRIMP (Primitive Imperative Language)</a>
<ul>
<li><a href="#primp-simulator">Primp Simulator</a></li>
<li><a href="#a-primp">A-PRIMP</a></li>
</ul>
</li>
<li><a href="#assembler-assignment">Assembler (assignment)</a>
<ul>
<li><a href="#converting-simp-into-a-primp-%22compiler%22">Converting SIMP into A-PRIMP (&quot;Compiler&quot;)</a></li>
</ul>
</li>
<li><a href="#c-strings">C Strings</a>
<ul>
<li><a href="#string-manipulation">String Manipulation</a>
<ul>
<li><a href="#comparing-strings">Comparing Strings:</a></li>
<li><a href="#reading-strings">Reading Strings:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#adding-functions-to-simp-simp-f">Adding Functions to SIMP (SIMP-F)</a></li>
<li><a href="#module-4-mmix">Module 4: MMIX</a>
<ul>
<li><a href="#mmix-machine">MMIX Machine</a></li>
<li><a href="#data-processing-instructions">Data processing instructions</a></li>
</ul>
</li>
</ul>
<h1 id="jan-8-reasoning-about-programming">Jan 8: Reasoning about programming</h1>
<p><em>CS13/45</em>  -&gt; Structural Recursion matches the Data Structure</p>
<h2 id="structural-recursion">Structural Recursion</h2>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">fact</span> n)    
	(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> n <span class="hljs-number">0</span>) <span class="hljs-number">1</span>
	(<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> n (<span class="hljs-name">fact</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">1</span>)))))

: A (<span class="hljs-name">listof</span> X) is:
	* empty or
	* (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> x y) where x is an X and y is a (<span class="hljs-name">listof</span> X)
</div></code></pre>
<p>If the recursion is structural, the structure of the program matches the structure of it's correctness proof by induction</p>
<p>Claim: (length L) produces the length of list L</p>
<pre><code class="language-none"><div>Case 1: L is empty
	(length L) produces 0, which is the length of L

Case 2: L is (cons x L`)
	Assume (length L`) produces N, the length L`.
	then L produces (+ 1 n) which is the length of L.
QED
</div></code></pre>
<h2 id="accumulative-recursion">Accumulative Recursion</h2>
<p>If the program is accumulative, the same does not work.</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">sum-list</span> L)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">sum-list-help</span> L acc)
		(<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> [(<span class="hljs-name">empty?</span> L) acc]
			   [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">sum-list-help</span> (<span class="hljs-name">rest</span> L) (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-name">first</span> L) acc))]))

	(<span class="hljs-name">sum-list-help</span> L <span class="hljs-number">0</span>))
</div></code></pre>
<p>Proving that sum-list produces the sum of the list L is the same as proving that (sum-list-help L 0) produces the sum of the list L</p>
<pre><code><div>Proof:

Case 1: L is empty
	then (sum-list L) = (sum-list-help L 0) = (sum-list-help empty 0) -&gt; 0. Done

Case 2: L is (cons x L`)
	Assume (sum-list-help L` 0) produces the sum of list L`

	(sum-list-help L 0) = (sum-list-help (cons x L`) 0) ~&gt; (sum-list-help L` x)  
</div></code></pre>
<p>Now we are stuck. The hypothesis has nothing about x, and x is not necessarily 0.</p>
<p>Proof Method: Induction on invariant. Generalize using acc.</p>
<pre><code><div>Proof:

Case 1: L is empty
	then (sum-list-help L acc) is (sum-list-help empty acc) -&gt; acc

Case 2: L is (cons x L`)
	Assume (sum-list-help L` acc) produces the sum of L` + acc

	(sum-list-help L acc) = (sum-list-help (cons x L`) acc) 
		~&gt; (sum-list-help L` (+ x acc))
		= sum of L` + (x + acc)
		= x + (sum of L`) + acc
		= (sum of L) + acc

	Set acc = 0
		(sum-list-help L 0) = sum of L

QED.
</div></code></pre>
<h2 id="generative-recurion">Generative Recurion</h2>
<ul>
<li>Does not follow the structure of the data. Proofs require more creativity</li>
</ul>
<p>How do we reason about imperative programs?</p>
<hr>
<p>title: &quot;LEC2: Impure Racket&quot;
author: Charles Zhang
date: &quot;2019-01-10&quot;
keywords: [Markdown, Example]
listings-no-page-break: true
...</p>
<h1 id="jan-10-impure-racket">Jan 10: Impure Racket</h1>
<p><code>(begin exp1, ... expn)</code></p>
<ul>
<li>evaluates expr_1 in left to right order</li>
<li>produces the value of exprn</li>
</ul>
<p>useless in a pure functional setting</p>
<ul>
<li>useful if expr_1, ... expr_n are evaluated for their side-effects.</li>
<li>Implicit begin in the bodies of functions, lambdas, locals, answers of cond/match.</li>
</ul>
<hr>
<h2 id="reasoning-about-side-effects">Reasoning about side effects.</h2>
<p>For pure functional programming, we use the substitution model</p>
<p><strong>Can the substitution model be adopted?</strong></p>
<ul>
<li>state of the world is an extra input and output at each step.</li>
<li>Each reduction step transforms the program and the slot of the world</li>
</ul>
<p><strong>How do we model the &quot;state of the world?&quot;</strong></p>
<ul>
<li>simple case: list of definitions</li>
<li>more complex cases: memory model (ram)</li>
</ul>
<p><em><strong>for now: Conceptualization of the machine</strong></em></p>
<p>Memory is a sequence of &quot;boxes&quot;</p>
<ul>
<li>indexed by natural #s (addresses)</li>
<li>containing a fixed-step # (say 32 bits)</li>
<li>any box's contents can be fetched in O(1) time</li>
</ul>
<p><strong>Modeling output.</strong></p>
<p>Simplest side-effect:</p>
<ul>
<li>&quot;state of the world&quot; is the sequence of characters that have been printed to the screen</li>
<li>each step of computation potentially adds chars to the sequence</li>
</ul>
<p>Note: every string is just a sequence of chars.</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">string-&gt;list</span></span> <span class="hljs-string">"abcd"</span>) -&gt; (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> <span class="hljs-literal">#\a</span> <span class="hljs-literal">#\b</span> <span class="hljs-literal">#\c</span> <span class="hljs-literal">#\d</span>)
</div></code></pre>
<p>\newpage</p>
<p><strong>32 bit ram (RAM)</strong></p>
<table>
<thead>
<tr>
<th>address</th>
<th>Contents</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1100111..</td>
</tr>
<tr>
<td>4</td>
<td>11000111..</td>
</tr>
<tr>
<td>8</td>
<td>1100101..</td>
</tr>
<tr>
<td>12</td>
<td>11001110.</td>
</tr>
<tr>
<td>..</td>
<td>..</td>
</tr>
<tr>
<td>256</td>
<td>1100011..</td>
</tr>
</tbody>
</table>
<hr>
<p>\newpage</p>
<h2 id="substitution-model">Substitution model</h2>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>π</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>π</mi><mn>3</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext>&ThinSpace;</mtext><mo separator="true">,</mo><msub><mi>π</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\pi_1, \pi_2, \pi_3, \cdots, \pi_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>each <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>π</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\pi_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is the version of the program obtained by applying one reduction step to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>π</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\pi_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>New also:
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>→</mo><msub><mi>ω</mi><mn>1</mn></msub><mo>→</mo><msub><mi>ω</mi><mn>2</mn></msub><mo>→</mo><mo>⋯</mo><mo>→</mo><msub><mi>ω</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\omega_0 \rightarrow \omega_1 \rightarrow \omega_2 \rightarrow \cdots \rightarrow \omega_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>each <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is a version of the output sequence</li>
<li>each <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is a <em>prefix</em> of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mo>(</mo></msub><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\omega_(i+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0147199999999998em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> (can't &quot;unprint&quot; chars)</li>
</ul>
<p>Combined:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>π</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>0</mn></msub><mo>)</mo><mo>→</mo><mo>(</mo><msub><mi>π</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>1</mn></msub><mo>)</mo><mo>→</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>→</mo><mo>(</mo><msub><mi>π</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>n</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(\pi_0, w_0) \rightarrow (\pi_1, w_1) \rightarrow ... \rightarrow (\pi_n, w_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>better to separate out the sequence of definitions, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span>:</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>π</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>δ</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>ω</mi><mn>0</mn></msub><mo>)</mo><mo>→</mo><mo>(</mo><msub><mi>π</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>δ</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>ω</mi><mn>1</mn></msub><mo>)</mo><mo>→</mo><mo>⋯</mo><mo>→</mo><mo>(</mo><msub><mi>π</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>δ</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(\pi_0, \delta_0, \omega_0) \rightarrow (\pi_1, \delta_1, \omega_1) \rightarrow \cdots \rightarrow (\pi_n, \delta_n, \omega_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>δ</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>ω</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\delta_0, \omega_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are empty</p>
<p>if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = <code>(define id exp)</code> ...</p>
<ul>
<li>reduce the expression according to the usual rules
<ul>
<li>may cause chars to be sent to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span></li>
</ul>
</li>
<li>expression now reduced to val</li>
<li>remove <code>(define id val)</code> from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span> and add to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span></li>
</ul>
<p>if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = exp ...</p>
<ul>
<li>reduce exp by the usual rules
<ul>
<li>may cause characters to be sent to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span></li>
</ul>
</li>
<li>expr now reduced to a value -&gt; remove from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span></li>
<li>chars that make up the value -&gt; added to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span></li>
</ul>
<p>When <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is empty</p>
<ul>
<li>done</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo separator="true">,</mo><mi>ω</mi></mrow><annotation encoding="application/x-tex">\delta, \omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span> - not static - that which changes, other than the program itself</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span> - relatively harmless - changes to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span> don't affect the running of the program.
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span> - not a problem yet becauase we're not yet changing (adding new definitions and really a style change)</p>
<hr>
<h2 id="affecting-omega-in-racket">Affecting <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span> in Racket</h2>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">display</span></span> x) <span class="hljs-comment">; outputs the value of x - no line break.</span>
(<span class="hljs-name"><span class="hljs-builtin-name">newline</span></span>) ` <span class="hljs-comment">; linebreak</span>
(<span class="hljs-name">printf</span> <span class="hljs-string">"the answer is ~a, \n"</span> x) <span class="hljs-comment">; formatted print. Value of x replaces ~a</span>
</div></code></pre>
<p><strong>but then, what do display, newline, printf return?</strong></p>
<ul>
<li><code>(display x)</code> returns nothing</li>
<li>try: (list (display 3))
<ul>
<li>produces <code>(#&lt;void&gt;)</code></li>
<li>not printed by dr-racket</li>
<li>for functions that don't produce anything useful</li>
<li>functions that return <code>(#&lt;void&gt;)</code> are called <strong>statements</strong> or <strong>commands</strong></li>
</ul>
</li>
</ul>
<p><strong>Recall:</strong></p>
<ul>
<li><code>(map (list l_1, ... ,l_n)) -&gt; (list (f l_1) (f l_2) ... (f l_n))</code></li>
<li>what does this return? <code>(list #&lt;void&gt; ... #&lt;void&gt;)</code></li>
</ul>
<p>Now consider:</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">for-each</span></span> f (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> l_1, ... l_n)`
	- performs: (<span class="hljs-name">f</span> l_1) ... (<span class="hljs-name">f</span> l_n)
	- produces: `#&lt;void&gt;`
</div></code></pre>
<p><strong>eg:</strong></p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">print-with-spaces</span> lst))
	(<span class="hljs-name"><span class="hljs-builtin-name">for-each</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (x) (<span class="hljs-name">printf</span> <span class="hljs-string">"~a "</span> x)) lst)

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">for-each</span></span> f list)
	(<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> [(<span class="hljs-name">empty?</span> lst) (<span class="hljs-name">void</span>)]
		  [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">f</span> (<span class="hljs-name">first</span> lst))
		  		(<span class="hljs-name"><span class="hljs-builtin-name">for-each</span></span> f (<span class="hljs-name">rest</span> lst))]))

<span class="hljs-comment">;; or, using if</span>

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">for-each</span></span> f lst)
		(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name">empty?</span> lst) 
			(<span class="hljs-name">void</span>)
			(<span class="hljs-name"><span class="hljs-builtin-name">begin</span></span> (<span class="hljs-name">f</span> (<span class="hljs-name">first</span> lst)) (<span class="hljs-name"><span class="hljs-builtin-name">for-each</span></span> f (<span class="hljs-name">rest-list</span>)))))
</div></code></pre>
<p>Doing nothing in one case of a condition is common and has a specialized form:</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">foreach</span> f lst)
		(<span class="hljs-name"><span class="hljs-builtin-name">unless</span></span> (<span class="hljs-name">empty?</span> lst) (<span class="hljs-name">f</span> (<span class="hljs-name">first</span> lst)) (<span class="hljs-name"><span class="hljs-builtin-name">for-each</span></span> f (<span class="hljs-name">rest</span> lst))))
</div></code></pre>
<ul>
<li>This evaluates body expressions if the test is false</li>
<li>similarly, <code>(when ...)</code> evaluates body expressions if the test is true</li>
</ul>
<hr>
<h2 id="reasoning-about-output-cont">Reasoning about output cont.</h2>
<p>Before we had output:</p>
<ul>
<li>the order of operations did not matter (assuming no crashes, non-termination)</li>
<li>now, order of the evaluation might affect the order of the output.</li>
<li>all non-terminating programs are equivalent (meaningless)</li>
</ul>
<p>Now, non-terminating programs can do interesting things. (eg: calculate digits of pi)</p>
<ul>
<li>the semantic model should include the possibility of non-terminating programs</li>
<li>meaning: what the program would produce &quot;in the limit&quot;</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span>, the set of all possible values of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span>, would include finite and infinite sequences of characters.</li>
</ul>
<p>Why do we need output?, we never used it in CS145</p>
<ul>
<li>Racket has a REPL, just calls functions + see the result.</li>
<li>Many languages:
<ul>
<li>Compile, link, execute cycle</li>
<li>program is translated (by a <strong>compiler</strong>) to native machine code, then executed from command line</li>
<li>you only see the output if the program prints it</li>
</ul>
</li>
</ul>
<p>\newpage</p>
<h1 id="jan-15-modelling-input">Jan 15: Modelling Input</h1>
<ul>
<li>
<p>Lets say you have an infinite sequence consisting of all characters the user will ever press : <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ι</mi></mrow><annotation encoding="application/x-tex">\iota</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ι</span></span></span></span></p>
<ul>
<li>Model now: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>π</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><mi>ω</mi><mo separator="true">,</mo><mi>ι</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(\pi, \delta, \omega, \iota)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ι</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>
<p>Accepting an input character removes a character from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ι</mi></mrow><annotation encoding="application/x-tex">\iota</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ι</span></span></span></span></p>
</li>
<li>
<p>But, the sequence <em>depends</em> on the output.</p>
<ul>
<li>You can't play a video game and press all the buttons first and let the game play out.</li>
<li>Users decide what to input in response to what is displayed on screen</li>
<li>You can't realistically assume all input is available at once</li>
</ul>
</li>
</ul>
<p><strong>Alternative</strong></p>
<p>A request for input yields a function consuming one or more characters and produces the next program &quot;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span>&quot; with the input characters substituted for the read request</p>
<p>eg:</p>
<p><code>(read-line)</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇝</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">\leadsto \lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.37788em;vertical-align:0em;"></span><span class="mrel amsrm">⇝</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span> (line) line, (user types &quot;abc&quot;), <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇝</mo></mrow><annotation encoding="application/x-tex">\leadsto</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.37788em;vertical-align:0em;"></span><span class="mrel amsrm">⇝</span></span></span></span> &quot;abc&quot;</p>
<ul>
<li>The entire program reduces to a big &quot;nesting&quot; of input request functions - one function per &quot;prompt&quot;
<ul>
<li>Supply user input for each prompt <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> yields final results</li>
</ul>
</li>
</ul>
<p>Proof techniques for imperative programs will be later</p>
<h2 id="input-in-racket">Input in Racket</h2>
<p><code>(read-line)</code></p>
<ul>
<li>produces a string consisting of all characters pressed until the first newline
<ul>
<li>the string does not contain the newline</li>
</ul>
</li>
</ul>
<p>Eg: <code>(string-&gt;list (read-line))</code></p>
<pre><code><div>Test. -&gt; `(#T #\e #\s #\t #\.)
</div></code></pre>
<p>Eg: Read a list of lines</p>
<ul>
<li>when do you know when to stop? -&gt; EOF</li>
<li>What is EOF?</li>
</ul>
<pre><code><div>&gt; (define x (read-line))
&gt; 
&gt; x
#&lt;eof&gt;
</div></code></pre>
<p>read-input until EOF:</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">read-input</span>)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> nl (<span class="hljs-name">read-line</span>))
	(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">eof-object?</span></span> nl) empty
		(<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> nl (<span class="hljs-name">read-input</span>)))
</div></code></pre>
<ul>
<li>Note: this is not tail recursive</li>
</ul>
<p><strong>More primitive input:</strong></p>
<ul>
<li>read-char - extracts one char from the input sequqnce</li>
<li>peek-char - examines the next character in the sequence but does not remove it</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">my-read-line</span>)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">mrl-h</span> acc)
		(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> ch (<span class="hljs-name"><span class="hljs-builtin-name">read-char</span></span>))
		(<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> [(<span class="hljs-name"><span class="hljs-builtin-name">or</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">eof-object?</span></span> ch) (<span class="hljs-name"><span class="hljs-builtin-name">char=?</span></span> ch <span class="hljs-literal">#\newline</span>)) 
				(<span class="hljs-name"><span class="hljs-builtin-name">list-&gt;string</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">reverse</span></span> acc))]
			  [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">mrl-h</span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> ch acc))]))

	(<span class="hljs-name">mrl-h</span> empty))
</div></code></pre>
<p><strong>Less primitive input:</strong></p>
<ul>
<li>read - consumes from input (and produces) an S-expression, no matter how many characters or lines it occupies
<ul>
<li>an S-expression is a well formed racket list or string (with parentheses and nesting)</li>
</ul>
</li>
</ul>
<pre><code class="language-scheme"><div>&gt; (<span class="hljs-name"><span class="hljs-builtin-name">read</span></span>)
(<span class="hljs-name">a</span> b (<span class="hljs-name">c</span> d e) f ((<span class="hljs-name">g</span>)) h)
&gt; `(a b (c d e) f ((g)) h)

&gt; (<span class="hljs-name"><span class="hljs-builtin-name">read</span></span>)
(<span class="hljs-name">a</span> b <span class="hljs-comment">;; Never ends</span>

&gt; (<span class="hljs-name"><span class="hljs-builtin-name">read</span></span>)
(<span class="hljs-name">a</span> b c) (<span class="hljs-name">d</span> e f)
&gt; `(a b c)
&gt; (<span class="hljs-name"><span class="hljs-builtin-name">read</span></span>)
&gt; `(d e f)
</div></code></pre>
<p>Let's implement <em>Dr Racket</em>:</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">repl</span>)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> exp (<span class="hljs-name"><span class="hljs-builtin-name">read</span></span>))
	(<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> [(<span class="hljs-name"><span class="hljs-builtin-name">eof-object?</span></span> exp) (<span class="hljs-name">void</span>)]
		  [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">display</span></span> (<span class="hljs-name">interp</span> (<span class="hljs-name">parse</span> exp)))
		         (<span class="hljs-name"><span class="hljs-builtin-name">newline</span></span>)
		         (<span class="hljs-name">repl</span>)]))
</div></code></pre>
<p>Let's implement (read)</p>
<ul>
<li>typically two steps (lots more detail in CS241)</li>
</ul>
<ol>
<li>Tokenization
<ul>
<li>Convert the sequence of raw characters to a sequence of <em>tokens</em> (meaningful words)</li>
<li>eg: left paren, right paren, id, number,
<ul>
<li>id: First character of an ID is always a character</li>
<li>number: First character of a number is always an int</li>
</ul>
</li>
<li>peeking at the next character tells us what the next token type should be and what to look for to complete the token</li>
<li><code>(struct token (type value))</code>
<ul>
<li>type: kind of token ('lp 'rp 'id 'num)</li>
<li>value: value of the token (numeric value, name, etc.)</li>
</ul>
</li>
<li>helpers:</li>
</ul>
</li>
</ol>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">token-left-par?</span> x) (<span class="hljs-name">symbol=?</span> (<span class="hljs-name">token-type</span> x) `lp)) 
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">token-right-par?</span> x) (<span class="hljs-name">symbol=?</span> (<span class="hljs-name">token-type</span> x) `rp))

<span class="hljs-comment">; read-id: -&gt; (listof char)</span>
<span class="hljs-comment">; Assumes the first character has already been read. Starts at the second.</span>
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">read-id</span>)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> nc (<span class="hljs-name"><span class="hljs-builtin-name">peek-char</span></span>))
	(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">or</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">char-alphabetic?</span></span> nc) (<span class="hljs-name"><span class="hljs-builtin-name">char-numeric?</span></span> nc))
		(<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">read-char</span></span>) (<span class="hljs-name">read-id</span>))
		empty))

<span class="hljs-comment">; read-number: -&gt; (listof char)</span>
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">read-number</span>)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> nc (<span class="hljs-name"><span class="hljs-builtin-name">peek-char</span></span>))
	(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">char-numeric?</span></span> nc)
		(<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">read-char</span></span>) (<span class="hljs-name">read-id</span>))
		empty))

<span class="hljs-comment">; Main Tokenizer:</span>
<span class="hljs-comment">; read-token -&gt; token</span>
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">read-token</span>)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> fc (<span class="hljs-name"><span class="hljs-builtin-name">read-char</span></span>)
	(<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> [(<span class="hljs-name"><span class="hljs-builtin-name">char-whitespace?</span></span> fc) (<span class="hljs-name">read-token</span>)]
		  [(<span class="hljs-name"><span class="hljs-builtin-name">char=?</span></span> fc <span class="hljs-literal">#\(</span>) (<span class="hljs-name">token</span> `lp fc)]
		  [(<span class="hljs-name"><span class="hljs-builtin-name">char=?</span></span> fc <span class="hljs-literal">#\)</span>) (<span class="hljs-name">token</span> `rp fc)]
		  [(<span class="hljs-name"><span class="hljs-builtin-name">char-alphabetic?</span></span> fc) (<span class="hljs-name">token</span> `id (<span class="hljs-name">list-&gt;symbol</span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> fc (<span class="hljs-name">read-id</span>)))]
		  [(<span class="hljs-name"><span class="hljs-builtin-name">char-numeric?</span></span> fc) (<span class="hljs-name">token</span> `id (<span class="hljs-name">list-&gt;symbol</span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> fc (<span class="hljs-name">read-number</span>)))]
		  [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">error</span> <span class="hljs-string">"lexical error"</span>)])))
</div></code></pre>
<ul>
<li>Note: <code>list-&gt;string and list-&gt;number</code> don't exist</li>
</ul>
<ol start="2">
<li>Parsing
<ul>
<li>are the tokens arranged into a sequence that has the structure of an s-expression?</li>
<li>if so, produce the s-expression</li>
<li>Helper:</li>
</ul>
</li>
</ol>
<pre><code class="language-scheme"><div><span class="hljs-comment">; read-list -&gt; (listof s-exp)</span>
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">read-list</span>) <span class="hljs-comment">; assumes left-paren has already been read.</span>
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> tk (<span class="hljs-name">read-token</span>))
	(<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> [(<span class="hljs-name">token-right-par?</span> tk) empty]
		  [(<span class="hljs-name">token-leftpar?</span> tk) (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name">read-list</span>) (<span class="hljs-name">read-list</span>))]
		  [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name">token-value</span> tk) (<span class="hljs-name">read-list</span>))]))

<span class="hljs-comment">; my-read -&gt; s-exp</span>
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">my-read</span>)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> tk (<span class="hljs-name">read-token</span>))
	(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name">token-leftpar?</span> tk)
		(<span class="hljs-name">read-list</span>)
		(<span class="hljs-name">token-value</span> tk)))
</div></code></pre>
<p><strong>Exercise:</strong></p>
<ul>
<li>different kinds of brackets ( a b [c d e] f), (a b {c d [e]} f)
<ul>
<li>they need to match</li>
</ul>
</li>
<li>other data types</li>
<li>generalize to other formats with proper nesting</li>
</ul>
<h2 id="downsides-of-input">Downsides of Input</h2>
<p>What have we lost by accepting input?</p>
<ul>
<li>referential transparency : the same expression has the same value wherever it is expressed
<ul>
<li>eg: <code>(f 4)</code> always produces the same value.</li>
<li><code>(left ((z (f 4))) body)</code>
<ul>
<li>every free z in body can be repalced by <code>(f 4)</code> and vice versa &quot;Equals can be substituted for equals&quot;</li>
</ul>
</li>
<li>not true anymore!
<ul>
<li>(read) doesn't produce the same value.</li>
<li>Simple algebraic manipulation is no longer possible.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>\newpage</p>
<h1 id="jan-17-intro-to-c">Jan 17: Intro to C</h1>
<ul>
<li>Developed at the same time as Unix.</li>
<li>Best for systems programming -&gt; No lies</li>
<li>Managing memory directly</li>
</ul>
<p>C has:</p>
<ul>
<li>Expressions -&gt; Statements -&gt; Blocks -&gt; Functions -&gt; Programs</li>
</ul>
<h2 id="expressions">Expressions:</h2>
<pre><code class="language-c"><div><span class="hljs-number">1</span> + <span class="hljs-number">2</span> <span class="hljs-comment">// Infix expression</span>
<span class="hljs-number">1</span> + <span class="hljs-number">2</span> * <span class="hljs-number">3</span> <span class="hljs-comment">// precedence is required (bedmas)</span>
f(<span class="hljs-number">4</span>) <span class="hljs-comment">//Function call</span>
<span class="hljs-number">3</span> + g(x,y,z)
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, <span class="hljs-number">5</span>)`
	<span class="hljs-comment">//5 goes in place of the %d</span>
	<span class="hljs-comment">//Produces # of characters printed</span>
</div></code></pre>
<h2 id="statements">Statements:</h2>
<pre><code class="language-c++"><div><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, <span class="hljs-number">5</span>);
</div></code></pre>
<pre><code>- has semicolon afterwards (finishes statement)
- semicolon turns any expression into a statement
- expr evaluated only for it's side-effects 
</code></pre>
<ul>
<li><code>1 + 2;</code> - legal but useless</li>
<li><code>return 0</code> - produce the value 0 as the result of this function (control returns to the caller)</li>
<li>; - empty statement -&gt; does nothing</li>
</ul>
<pre><code class="language-c++"><div><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span> <span class="hljs-number">5</span>);;;;;;;;;;;;;;;;;;;;
</div></code></pre>
<ul>
<li>Other statements will come up as we need them</li>
</ul>
<h2 id="block">Block:</h2>
<ul>
<li>Group of statements treated as one statement</li>
</ul>
<pre><code class="language-c"><div>{
	stmt_1
	stmt_2
	...
	stmt_n
}

<span class="hljs-comment">//Think:</span>

{<span class="hljs-keyword">void</span>
	stmt_1
	stmt_2
	...
	stmt_n
}
</div></code></pre>
<h2 id="functions">Functions</h2>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"x = %d, y = %d\n"</span>, x,y)
	<span class="hljs-keyword">return</span> x + y;
}

<span class="hljs-comment">// Similar to:</span>
<span class="hljs-comment">// f: Num Num -&gt; Num</span>
(define (f x y)
	(<span class="hljs-built_in">printf</span> <span class="hljs-string">"x = ~a, y = ~a\n"</span> x y)
	(+ x y)
</div></code></pre>
<p>function call:</p>
<ul>
<li><code>f(4,3)</code> is an expression (returns 7)</li>
<li><code>f(4,3);</code> is an expression</li>
</ul>
<p>Racket:</p>
<ul>
<li>(f 4 3)</li>
<li>(void (f 4 3))</li>
</ul>
<p>Note in c:</p>
<ul>
<li>contracts (type signatures) are required and enforced</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{...}
</div></code></pre>
<ul>
<li>Racket is dynamically typed. C is statically typed</li>
</ul>
<h2 id="programs-a-sequence-of-functions">Programs: a sequence of functions</h2>
<ul>
<li>Need a starting point: int main()</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	f(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{...}
</div></code></pre>
<p>This doesn't compile. Why?</p>
<ul>
<li>when the function gets compiled, it doesn't know what f is when it reaches main()</li>
<li>C enforces declaration before use. You can't use a function or variable before it is declared.</li>
</ul>
<p>Solution 1: Put f first</p>
<pre><code class="language-c"><div>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{...}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	f(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>OK, but more than necessary</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{...}
</div></code></pre>
<p>is both a <strong>declaration</strong>(dells C about the function) and a <strong>definition</strong>(completely constructs the function.</p>
<p>C only requires <strong>declaration</strong> before use, so yo ucan have a function prototype, or header.</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>;
</div></code></pre>
<p>Solution 2: Prototype</p>
<pre><code class="language-c"><div>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	f(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"x = %d, y = %d\n"</span>, x,y)
	<span class="hljs-keyword">return</span> x + y;
}

</div></code></pre>
<p>Still doens't compile. You need to include printf</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(????)</span>
<span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	f(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"x = %d, y = %d\n"</span>, x,y)
	<span class="hljs-keyword">return</span> x + y;
}

</div></code></pre>
<p>This will theoretically work if you know what to put for ????.</p>
<p>Rather than declare every standard library function prototype, C provides header files.</p>
<pre><code class="language-c"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
</div></code></pre>
<ul>
<li>Not part of the C language.</li>
<li>Directive to the <strong>C proeprocessor</strong> (which runs before the compiler)
<ul>
<li>macro expression in Racket</li>
</ul>
</li>
</ul>
<p>stdio.h contains declarations for printf/otherIO functions.
- located in a standarad place -&gt; &quot;/usr/include&quot;</p>
<p>Now the compiler is satisfied.</p>
<ul>
<li>but still technically incomplete.</li>
</ul>
<p>Code for printf must be combined with our code - Linking</p>
<ul>
<li>a linker takes care of this - runs automatically.
<ul>
<li>knows to link in code for printf</li>
</ul>
</li>
</ul>
<p>-f you write your own modules, you need to tell the linker about them</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	...
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// tells the OS (echo #?)</span>
}
</div></code></pre>
<h2 id="variables">Variables</h2>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{
	<span class="hljs-keyword">int</span> z = x + y;
	<span class="hljs-keyword">int</span> w = <span class="hljs-number">2</span>;
	<span class="hljs-keyword">return</span> z /w;
}
</div></code></pre>
<p>Input:</p>
<pre><code class="language-c"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">char</span> c = getchar()
	<span class="hljs-keyword">return</span> c;
}
</div></code></pre>
<ul>
<li>This doesn't break because a char is stored as a small int</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getIntHelper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acc)</span></span>{
	<span class="hljs-keyword">char</span> c = getchar();
	<span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'0'</span>) <span class="hljs-keyword">return</span> gitIntHelper(acc * <span class="hljs-number">10</span> + c - <span class="hljs-string">'0'</span>;
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> acc);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">return</span> getIntHelper(<span class="hljs-number">0</span>);
}
</div></code></pre>
<p>OR</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getIntHelper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acc)</span></span>{
	<span class="hljs-keyword">char</span> c = getchar();
	<span class="hljs-keyword">return</span> (c &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>)? getIntHelper(<span class="hljs-number">10</span> * acc + c - <span class="hljs-string">'10'</span>) : acc;
}
</div></code></pre>
<p><strong>Notes:</strong></p>
<ul>
<li>Boolean Conditions, &gt;= &lt;= &amp;&amp; ||</li>
<li>if (){BLOCK} else {BLOCK}</li>
</ul>
<p>Dangling else problem:</p>
<pre><code class="language-c"><div><span class="hljs-keyword">if</span> (cond1)
	<span class="hljs-keyword">if</span> (cond2)
		statement1;
<span class="hljs-keyword">else</span>
	statement2;
</div></code></pre>
<p>Where does the else go? <strong>with cond2</strong></p>
<ul>
<li>
<p>else goes with the closest unmatched if</p>
<ul>
<li>Just use the damn braces mate</li>
</ul>
</li>
<li>
<p>CONDITIONAL OPERATOR: ?:</p>
<ul>
<li>if-else is a <strong>statement</strong></li>
<li>?: creates an <strong>expression</strong></li>
<li><code>a ? b : c</code> has value b if a is true, value c if a is false</li>
<li>Note: No built in boolean type in c : 0 is false, nonzero is true</li>
<li><code>if (0) {...}</code> will never execute</li>
</ul>
</li>
<li>
<p>Boolean Type with constants True / False</p>
</li>
</ul>
<h2 id="characters">Characters</h2>
<ul>
<li>
<p>Characters are a type of restricted integer (8 bits, 256 values)</p>
</li>
<li>
<p>Integers vary, generally 32bits -&gt; (~4x10^9 distinct values)</p>
</li>
<li>
<p>'0' is the character 0 (Numerically 48)</p>
</li>
<li>
<p>'9' (numerically 57)</p>
</li>
<li>
<p><code>char c = '0';</code> is identical to <code>char c = 48;</code></p>
</li>
<li>
<p>Everything in memory is a number</p>
</li>
<li>
<p>Each character must be represented by numeric code (<strong>ASCII</strong>)</p>
<ul>
<li>American Standard Code for Information Interchange</li>
</ul>
</li>
<li>
<p>ASCII:</p>
<ul>
<li><code>\n</code> = 10</li>
<li>' ' = 32</li>
<li>'0-9' = 48-57</li>
<li>'A-Z' = 65-90</li>
<li>'a-z' = 97-122</li>
</ul>
</li>
</ul>
<p>getchar():</p>
<ul>
<li>Char c = getchar();</li>
<li>but, the prototype for getchar is actually <code>int getchar()</code></li>
<li>why int if it's supposed to produce a char?
<ul>
<li>What if there are no chars? (EOF)</li>
<li>if a char is returned, no way to indicate EOF</li>
<li>if no characters in buffer, return an int that can't be a char (ie: not in range 0-255), mostly -1</li>
</ul>
</li>
</ul>
<h2 id="next-question">Next Question:</h2>
<ul>
<li>97ABC_</li>
<li>getint(); then getchar(); produces what?</li>
<li>B</li>
<li>getint(); burns a character</li>
<li>you have ungetc(); puts back a character</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peekchar</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> c = getchar();
	<span class="hljs-keyword">return</span> c == EOF? EOF : ungetc(c,<span class="hljs-built_in">stdin</span>)
}
</div></code></pre>
<p>Improved getint() // doesn't burn a character</p>
<pre><code class="language-c"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt; // character predicates</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getIntHelper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acc)</span></span>{
	<span class="hljs-keyword">int</span> c = peekchar()
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">isdigit</span>(c)? getIntHelper10(<span class="hljs-number">10</span> * acc + getchar() - <span class="hljs-string">'0'</span>) : acc;
}

<span class="hljs-comment">// more efficiently: Don't call getchar twice per char</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getIntHelper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acc)</span></span>{
	<span class="hljs-keyword">int</span> c = getchar()

	<span class="hljs-keyword">return</span> <span class="hljs-built_in">isdigit</span>(c)? getIntHelper(<span class="hljs-number">10</span> * acc + c - <span class="hljs-string">'0'</span>) : 
		(ungetc(c, <span class="hljs-built_in">stdin</span>), acc);
}

</div></code></pre>
<h2 id="comma-operator">Comma Operator</h2>
<ul>
<li><code>(a,b)</code> evaluates a then evaluate b and return b
<ul>
<li>Exactly like <strong>(begin a b)</strong></li>
</ul>
</li>
</ul>
<p>What if there's whitespace before we reach the end?</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">skipws</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> c = getchar();
	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c)) {
		skipwhs();
	}
	<span class="hljs-keyword">else</span> ungetc(c,<span class="hljs-built_in">stdin</span>);
}
</div></code></pre>
<ul>
<li>Void functions return nothing
<ul>
<li>There are no void variables -&gt; only good for side effects</li>
<li>Returning from void functions:
<ul>
<li>reach the end</li>
<li><code>return;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>{
	skipws();
	<span class="hljs-keyword">return</span> getIntHelper(<span class="hljs-number">0</span>);
}
</div></code></pre>
<p>\newpage</p>
<h1 id="jan-24-mutation">Jan 24: Mutation</h1>
<h2 id="mutation-in-racket">Mutation in Racket</h2>
<p>Basic notation: <code>set!</code> (! = &quot;bang&quot; - indicates weirdness)</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> x <span class="hljs-number">3</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> x <span class="hljs-number">4</span>)
</div></code></pre>
<ul>
<li>set! produces (void) and changes <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span> (list of definitions)</li>
<li>x must have been previously defined</li>
</ul>
<p>Ex:</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">lookup</span> `Brad)
&gt; false
(<span class="hljs-name">add</span> `Brad <span class="hljs-number">36484</span>)
(<span class="hljs-name">lookup</span> `brad)
&gt; <span class="hljs-number">36484</span>
</div></code></pre>
<p>Not possible in pure racket. Now, the same expression can produce multiple results.</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> address-book empty)
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">add</span> name number)
	(<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> address-book (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> name number) address-book))
</div></code></pre>
<ul>
<li>address-book is a global variable (accessible throughout the program)
<ul>
<li>good for defining constants that need to be used repeatedly</li>
<li>But, once you have mutation it's not as good
<ul>
<li>Any part of the program could change a global variable</li>
<li>Affects the entire program</li>
<li>Hidden dependencies among distinct functions</li>
<li>Harder to understand what the program is doing</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="application-memoization">Application: Memoization</h3>
<ul>
<li><em>Caching</em> : saving the result of a computation to avoid repeating it</li>
<li>Memoization is just maintaining a list of cached values systematically</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">fib</span> n)
		(<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> 	[(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> n <span class="hljs-number">0</span>) <span class="hljs-number">0</span>]
				[(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> n <span class="hljs-number">1</span>) <span class="hljs-number">1</span>]
				[<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-name">fib</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">1</span>)) (<span class="hljs-name">fib</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">2</span>)))]))
</div></code></pre>
<ul>
<li>this is pretty trash</li>
<li>repetition of recursive calls</li>
<li>(fib 100) calls (fib 99) * 1, (fib 98) * 2, (fib 97) * 3,  (fib 96) * 5, (fib 95) * 8, so on
<ul>
<li>O(Fn) time (where Fn is the n'th fibinacci number) ~ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>ϕ</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\phi^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo>=</mo><mfrac><mrow><mn>1</mn><mo>+</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\phi = \frac{1 + \sqrt{5}}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3829999999999998em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0379999999999998em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.3990085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">5</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> fib-table empty)

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">memo-fib</span> n)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> result (<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> n fib-table))
	(<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> 	[<span class="hljs-name">result</span> =&gt; second]
			[<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> fib-n 
				(<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> 	[(<span class="hljs-name"><span class="hljs-builtin-name">&lt;=</span></span> n <span class="hljs-number">1</span>) n]
						[<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-name">memo-fib</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">1</span>)) (<span class="hljs-name">memo-fib</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">2</span>)))]))
				(<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> fib-table (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> n fib-n) fib-table))
				fib-n]))
</div></code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>
<p>Assoc -&gt; built in function for association list lookup</p>
<ul>
<li><code>(assoc x lst)</code> returns pair (x y) from lst or false</li>
</ul>
</li>
<li>
<p>Any value that is not false is true.</p>
</li>
<li>
<p><code>(cond [x =&gt; f])</code></p>
<ul>
<li>if X is not false, then produce <code>(f x)</code></li>
</ul>
</li>
<li>
<p>Calls to (fib n) now only happen once</p>
<ul>
<li>Not without flaws: the memo list is in descending order <code>((fib 1000) (fib 999) (fib 998))</code> etc.</li>
<li>Very fast to calculate <code>(fib 1001)</code> because assoc is fast, but <code>(fib 1)</code> is  slow.</li>
</ul>
</li>
<li>
<p>fib-table is a global variable. Can we hide it?</p>
</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> memo-fib
  (<span class="hljs-name">local</span>
    [(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> fib-table empty)

     (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">memo-fib</span> n)
       (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> result (<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> n fib-table))
       (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> [<span class="hljs-name">result</span> =&gt; second]
             [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> fib-n 
                     (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> [(<span class="hljs-name"><span class="hljs-builtin-name">&lt;=</span></span> n <span class="hljs-number">1</span>) n]
                           [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-name">memo-fib</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">1</span>)) (<span class="hljs-name">memo-fib</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">2</span>)))]))
                   (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> fib-table (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> n fib-n) fib-table))
                   fib-n]))]
    memo-fib))
</div></code></pre>
<ul>
<li>doesn't quite work for address-book since there are two functions that need access to it</li>
</ul>
<p>\newpage</p>
<h2 id="mutation-in-c">Mutation in C:</h2>
<ul>
<li>Assignment Operator '=' performs mutation</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, x);
	x = <span class="hljs-number">4</span>; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, x);
}
</div></code></pre>
<ul>
<li>= is an operator</li>
<li><code>x = y</code> is an expression -&gt; it has a value and it has an effect
<ul>
<li>it's value is the value assigned
<code>x = 4</code> sets x to 4 and has value 4</li>
</ul>
</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, x);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, x = <span class="hljs-number">4</span>);
}
</div></code></pre>
<ul>
<li>Advantages: Almost none</li>
<li>Disadvantages: Lots</li>
</ul>
<p>Eg: <code>x = y = z = 7</code> sets all of x,y,z to 7</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;
	<span class="hljs-keyword">if</span> (x = <span class="hljs-number">4</span>){	<span class="hljs-comment">// assigns x to 4, always returns true</span>
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"x is 4 \n"</span>);
	}
	x = <span class="hljs-number">0</span>
	<span class="hljs-keyword">if</span> (x = <span class="hljs-number">0</span>) { <span class="hljs-comment">// assigns x to 0, always prints false</span>
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"x is 0\n"</span>);
	}
}
</div></code></pre>
<ul>
<li>Prints: &quot;x = 4&quot;</li>
<li>easy to confuse assignment with operator</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-keyword">if</span> (x == <span class="hljs-number">4</span>) ...
<span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) ...
</div></code></pre>
<p>Usually best to use assignment only as a statement</p>
<p>Can leave vars uninitiated and assign them later:</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> x; <span class="hljs-comment">//uninitialized </span>
	x = <span class="hljs-number">4</span>; <span class="hljs-comment">// not a good idea. Do only with a really good reason</span>
}

<span class="hljs-comment">// eg: </span>
<span class="hljs-keyword">int</span> x;
<span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>){
	<span class="hljs-comment">// Will this run? DUNNNO BRO</span>
}
</div></code></pre>
<ul>
<li>The uninitialized variable is undefined.</li>
<li>Typically, it's whatever value was in that memory from before</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>{ <span class="hljs-comment">// returns 0 then 1 then 2 then ...</span>
	<span class="hljs-keyword">int</span> d = c;
	c = c + <span class="hljs-number">1</span>;
	<span class="hljs-keyword">return</span> d;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, f());
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, f());
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, f());

<span class="hljs-comment">// prints 0, 1, 2</span>

<span class="hljs-comment">//BUT:</span>

<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n%d\n%d\n"</span>, f(), f(), f());
<span class="hljs-comment">// could produce 0 1 2 or 2 1 0 or other!</span>
</div></code></pre>
<ul>
<li>ORDER OF EVALUATION IS UNSEPCIFIED</li>
<li>Never mutate and access in the same expression</li>
</ul>
<p>As with the racket address book, we can interfere with f by mutating c.
Can we protect c from access by functions other than f?</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span> d = c;
	c = c + <span class="hljs-number">1</span>;
	<span class="hljs-keyword">return</span> d
}
</div></code></pre>
<ul>
<li>C does not reset to 0 every time you enter the function</li>
</ul>
<p>\newpage</p>
<h1 id="jan-29-repetition">Jan 29: Repetition</h1>
<ul>
<li>Tail recursive: Nothing is done after the recursive call
<ul>
<li>tail recursive is just repetition</li>
</ul>
</li>
</ul>
<h2 id="while-loop">While Loop</h2>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHiNTimes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{
	<span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>){
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hi"</span>);
		SayHiNTimes(n - <span class="hljs-number">1</span>);
	}
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHiNTimes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{
	<span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>){
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hi\n"</span>);
		n = n - <span class="hljs-number">1</span>;
	}
}

</div></code></pre>
<ul>
<li>While loop
<ul>
<li>body of the loop is executed repeatedly</li>
</ul>
</li>
</ul>
<p>In general:</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>{
	<span class="hljs-keyword">if</span> (cont(c)) { <span class="hljs-comment">// Continuation Condition</span>
		body(c);
		f(update(c));
	}
}

<span class="hljs-comment">// becomes:</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>{
	<span class="hljs-keyword">while</span> (cont(c)){
		body(c);
		update(c);
	}
}
</div></code></pre>
<ul>
<li>May not need to be in it's on function any more, if it it's used only once</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-comment">// Accumulators:</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> acc)</span></span>{
	<span class="hljs-keyword">if</span> (cont(c)){
		body(c,acc);
		<span class="hljs-keyword">return</span> f(update1(c),update2(c));
	}	
	<span class="hljs-keyword">return</span> g(acc);
}

f(c, acc0);

<span class="hljs-comment">// Becomes:</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c0, <span class="hljs-keyword">int</span> acc0)</span></span>{

	<span class="hljs-keyword">int</span> acc = acc0;
	<span class="hljs-keyword">int</span> c = c0;
	<span class="hljs-keyword">while</span> (cont(c)){
		body(c, acc);
		acc = update2(acc, c);
		c = update1(c);
	}
	acc = g(acc);
}

</div></code></pre>
<p>Another Example:</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getIntHelper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acc)</span></span>{
	<span class="hljs-keyword">char</span> c = getchar();
	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) <span class="hljs-keyword">return</span> getIntHelper(<span class="hljs-number">10</span> * acc + c - <span class="hljs-string">'0'</span>);
	<span class="hljs-keyword">return</span> acc;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">return</span> getIntHelper(<span class="hljs-number">0</span>);
}
</div></code></pre>
<p>Becomes:</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> acc = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">char</span> c = getchar();
	<span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(c)){
		acc = <span class="hljs-number">10</span> * acc + c - <span class="hljs-string">'0'</span>;
		c = getchar();
	}
}
</div></code></pre>
<p>Common Pattern:</p>
<pre><code class="language-c"><div>
<span class="hljs-comment">//(initialize variables)</span>

<span class="hljs-keyword">while</span> (condition){
	<span class="hljs-comment">// body</span>
	<span class="hljs-comment">// update variables</span>
}
</div></code></pre>
<h2 id="for-loop">For Loop</h2>
<ul>
<li>Don't <strong>for</strong> get initialization and updating</li>
</ul>
<p>Alternative format:</p>
<pre><code class="language-c"><div><span class="hljs-keyword">for</span> (intit; condition; update){
	body
}
</div></code></pre>
<p>Returning to getInt():</p>
<pre><code class="language-c"><div><span class="hljs-comment">//eg:</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> acc = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">char</span> c;
	<span class="hljs-keyword">for</span> (c = getchar(); <span class="hljs-built_in">isdigit</span>(c); c = getchar()){
		acc = <span class="hljs-number">10</span> * acc + c - <span class="hljs-string">'0'</span>;
	}
}

<span class="hljs-comment">// or even</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> acc = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c = getchar(); <span class="hljs-built_in">isdigit</span>(c); acc = <span class="hljs-number">10</span> * acc + c - <span class="hljs-string">'0'</span>, c = getchar());
}

</div></code></pre>
<ul>
<li>Note you can only define one type of variable in the for loop
<ul>
<li><code>int a = 0, b = 0</code> works, but <code>int a = 0, char c = 0</code> does not. Also be careful about scoping</li>
</ul>
</li>
</ul>
<p>Peekchar Version:</p>
<pre><code class="language-c"><div>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> acc = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c = peekchar(); <span class="hljs-built_in">isdigit</span>(c); acc = <span class="hljs-number">10</span> * acc + getchar() - <span class="hljs-string">'0'</span>, c = peekchar());
}


<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> acc = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c = peekchar(); <span class="hljs-built_in">isdigit</span>(c); c = (getchar(), peekchar())){
		acc = <span class="hljs-number">10</span> * acc + c - <span class="hljs-string">'0'</span>;
	}
}

</div></code></pre>
<ul>
<li>Remember comma operator: (f,g) -&gt; evaluate f, return g</li>
</ul>
<h2 id="updating-counters">Updating Counters</h2>
<pre><code class="language-c"><div>c = c + <span class="hljs-number">1</span>;
c = c - <span class="hljs-number">2</span>;
c = <span class="hljs-number">10</span> * c;
c = c / <span class="hljs-number">2</span>;
c = c + d;
</div></code></pre>
<p>You have special syntax:</p>
<pre><code class="language-c"><div>c += <span class="hljs-number">1</span>;
c -= <span class="hljs-number">2</span>;
c *= <span class="hljs-number">10</span>;
c /= <span class="hljs-number">2</span>;
c += d;
</div></code></pre>
<p>Incrementing and Decrementing by 1;</p>
<pre><code class="language-c"><div>++c;
--i;
</div></code></pre>
<p>Increment c, decrement i</p>
<ul>
<li>These are expressions - they have a value as well as an effect
<ul>
<li>++c increments c and produces the value of c.</li>
<li>--i decrements i and produces the value of i.</li>
<li><strong>Which Value?</strong></li>
</ul>
</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ++i);

<span class="hljs-comment">// prints 1</span>
</div></code></pre>
<ul>
<li>++c gives the new value</li>
<li>but, c++, c-- gives the old value.
<ul>
<li>either has to remember the old value or re-compute the old value</li>
</ul>
</li>
<li>Just use prefix.</li>
</ul>
<h2 id="global-constants">Global Constants</h2>
<ul>
<li>Constants are still useful, but making it mutable is not great.</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> passingGrade = <span class="hljs-number">50</span>;
</div></code></pre>
<h2 id="intermediate-mutation-racket">Intermediate Mutation (Racket)</h2>
<ul>
<li>What if we want to work with multiple address books?</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> work '((<span class="hljs-string">"Manager' 12345)("</span>Director<span class="hljs-string">" 23456))
(define home '()')

(define (add-entry abook name number)
	(set! abook (cons (list name number) abook)))

(add-entry home "</span>Neighbour<span class="hljs-string">" 34567)
</span></div></code></pre>
<ul>
<li>No change to home! Why?</li>
<li>How do you make it work?</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name">add-entry</span> home <span class="hljs-string">"Neighbour"</span> <span class="hljs-number">34567</span> `())
-&gt; (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> `() (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> <span class="hljs-string">"Neighbour"</span> <span class="hljs-number">34567</span>) `()))

Do I want to change the empty list? what? 
</div></code></pre>
<p>To make this work, build a struct out of lambdas</p>
<ul>
<li>Make a struct with one field : called a <em>box</em></li>
<li>two operations:
<ul>
<li>get the value in the box</li>
<li>set the value to a new value</li>
</ul>
</li>
</ul>
<pre><code><div>(define (make-box V)
	(lambda (msg)
		(cond [(equal? msg `get) v])))

(define (get b) (b `get))
</div></code></pre>
<p>How this works:</p>
<pre><code><div>(define b1 (make-box 7))
(get b1)

=&gt; (define b1 (lambda (msg) (cond [(equal? msg `get) 7])))
	(get b1)
=&gt; (get (lambda (msg) (cond [(equal? msg `get) 7])))
=&gt; ((lambda (msg) (cond [(equal? msg `get) 7]))) `get)
=&gt; (cond [(equal? `get `get) 7])
=&gt; 7
</div></code></pre>
<ul>
<li>How do I support <code>set</code> ?
<ul>
<li>Introduce a local copy of v:</li>
</ul>
</li>
</ul>
<pre><code><div>(define (make-box v)
	(define val v)
	(lambda (msg) 
		(cond 
			[(equal? msg `get) val]
			[(equal? msg `set) 
				(lambda (newv) (set! val newv))])))

(define (get b) (b `get))
(define (set b v) ((b `set) v))
</div></code></pre>
<p>Trace:</p>
<pre><code><div>(define b1 (make-box 7))
(set b1 4)

=&gt; 	(define b1 (local [(define val 7)] (lambda (msg) ...)))
	(set b1 4) w
=&gt; 	(define (val_1 7))
	(define b1 (lambda (msg) 
				(cond 
					[(equal? msg `get) val_1]
					[(equal? msg `set) 
						(lambda (newv) (set! val_1 newv))])))
	(set b1 4) 
=&gt;	(define (val_1 7))
	(define ...)
	((b1 `set) 4)

=&gt; 	(define (val_1 7))
	(define ...)
	(((lambda (msg) 
		(cond 
			[(equal? msg `get) val_1]
			[(equal? msg `set) 
				(lambda (newv) (set! val_1 newv))])) `set) 4)
=&gt; 	...
=&gt; 	(define (val_1 7))
	(define ...)
	(lambda (newv) (set! val_1 newv) 4)

=&gt;	(define (val_1 7))
	(define ...)
	(set! val_1 4)

</div></code></pre>
<p>Previously, the issue was that &quot;home&quot; is the empty list.
Now, &quot;Home&quot; is something that knows how to fetch / set the variable on demand.</p>
<p>This is a <strong>BOX</strong></p>
<p>\newpage</p>
<h1 id="jan-31-boxes">Jan 31: Boxes</h1>
<pre><code><div>(add home ___ ___)
</div></code></pre>
<p>Home is a function that can update the created variable</p>
<ul>
<li>Boxes are built into racket. Syntax:</li>
</ul>
<pre><code><div>exp = (box exp)
	| (unbox exp)
	| (set-box! exp exp)

</div></code></pre>
<p>So the &quot;Home&quot; function:</p>
<pre><code><div>(define work (box `((&quot;Manager&quot; 12345) (&quot;Director&quot; 54321))))

(define (add-book name num)
	(set-box! book (cons (list name num) (unbox book))))
</div></code></pre>
<h2 id="stepping-semantics">Stepping Semantics</h2>
<pre><code><div>(box v) (v a value)
=&gt; (define _u v) (u is a fresh name)
	_u
</div></code></pre>
<p><strong>Convention:</strong></p>
<ul>
<li>When an underscore appears before a variable name, don't look up the value of the variable unless <code>(unbox __)</code> is called. Leave it as is.</li>
</ul>
<pre><code><div>(unbox _n)  - find (define _n v) that should be somewhere
=&gt; v

(set-box! _n v) - find (define _n ___) and replace with (define _n v)
</div></code></pre>
<p>EG:</p>
<pre><code><div>(define box1 (box 4))
(unbox box1)
(set-box! box1 true)
(unbox box1)

=&gt; 	(define _u1 4)
	(define box1 _u1) // in old rules, this would have been a 4.
	(unbox box1)
	(set-box! box1 true)
	(unbox box1)
=&gt;	(define _u1 4)
	(define box1 _u1)
	(unbox _u1)
	(set-box! box1 true)
	(unbox box1)
=&gt;	(define _u1 4)
	(define box1 _u1)
	4
	(set-box! box1 true)
	(unbox box1)
=&gt;	(define _u1 4)
	(define box1 _u1)
	4
	(set-box! _u1 true)
	(unbox box1)
=&gt; 	(define _u1 true)
	(define box1 _u1)
	4
	(void)
	(unbox box1)
=&gt; 	(define _u1 true)
	(define box1 _u1)
	4
	(void)
	(unbox _u1)
=&gt; 	(define _u1 true)
	(define box1 _u1)
	4
	(void)
	true

</div></code></pre>
<p>\newpage</p>
<ul>
<li>a bit messy. Substitution model is a bit messed for mutation</li>
</ul>
<p>You get the same problem in c</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inc</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{
	x = x + <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;
	inc(x)
	print(<span class="hljs-string">"%d\n"</span>, x)
}
</div></code></pre>
<p>Want 2, gets 1 - only passes a copy</p>
<p>Racket's solution: put the variable in the box. What's C's equivalent?</p>
<ul>
<li>One field structure?</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Posn</span>{</span>
	<span class="hljs-keyword">int</span> x;
	<span class="hljs-keyword">int</span> y;
};
</div></code></pre>
<p>Why is the semicolon there?</p>
<pre><code class="language-c"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Posn</span>{</span> ... } s1,s2,s3; 
</div></code></pre>
<ul>
<li>define struct then define variables that are the same type of the struct</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Posn</span> <span class="hljs-title">p</span>;</span>
	p.x = <span class="hljs-number">3</span>;
	p.y = <span class="hljs-number">4</span>;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"p = (%d, %d)\n"</span>, p.y, p.y);
}

<span class="hljs-comment">// or</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Posn</span> <span class="hljs-title">p</span> = {</span><span class="hljs-number">3</span>,<span class="hljs-number">4</span>};
}

<span class="hljs-comment">// but NOT:</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Posn</span> <span class="hljs-title">p</span>;</span>
	p = {<span class="hljs-number">3</span>,<span class="hljs-number">4</span>};
}
</div></code></pre>
<p>Does it solve the problem?</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(struct Posn p)</span></span>{
	<span class="hljs-keyword">int</span> temp = p.x;
	p.x = p.y;
	p.y = temp;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Posn</span> <span class="hljs-title">p</span> = {</span><span class="hljs-number">3</span>,<span class="hljs-number">4</span>};
	swap(p);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"p = (%d, %d)\n"</span>, p.y, p.y);
}
</div></code></pre>
<ul>
<li>Still prints (3, 4)</li>
<li>Works in racket but not c?
<ul>
<li>Racket is telling liesssss</li>
</ul>
</li>
</ul>
<p>Problem: C and racket passes parameters by <em><strong>call-by-value</strong></em>. The function operates on a copy of the argument, not the argument itself.</p>
<p>Note that the racket substitution model does implement call by value</p>
<pre><code><div>(define x 3)
(define f x) -&gt; (f 3)  // this is the value of x, not x itself
</div></code></pre>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{
	++x;
}
</div></code></pre>
<p>Note: x really does get mutated, but it's a copy of x and not the original from the caller. The original remains the same</p>
<ul>
<li>There is something special about boxes</li>
<li>They tell you how to FIND the value , not the value they actually hold
<ul>
<li>unbox = find the value</li>
</ul>
</li>
<li>Finding the value: Where was it located?
<ul>
<li>Located in memory somewhere (RAM) -&gt; Address</li>
<li>Addresses can function as boxes</li>
<li>instead of passing a function, pass an address</li>
</ul>
</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inc</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{
	x = x + <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;
	inc(&amp;x)
	print(<span class="hljs-string">"%d\n"</span>, x)
}
</div></code></pre>
<ul>
<li>But here, the type of inc is wrong.</li>
<li>What type is data is stored at that address?</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x)</span></span>{ <span class="hljs-comment">// x is a pointer to an int (address of an int)</span>
	*x = *x + <span class="hljs-number">1</span>  
}
</div></code></pre>
<ul>
<li><code>*</code> is the dereference operator, fetch the value stored at that address</li>
</ul>
<p>Alternatives:</p>
<pre><code class="language-c"><div>*x += <span class="hljs-number">1</span>
++*x 

<span class="hljs-comment">// but this doesn't work</span>
*x++
</div></code></pre>
<ul>
<li>What happens first in <code>*x++</code>? <strong>ALWAYS POSTFIX BEFORE PREFIX</strong>
<ul>
<li><code>*(x++)</code></li>
<li>increments address then fetches the data, then throwing it away.</li>
<li>want <code>(*x)++</code></li>
</ul>
</li>
</ul>
<p>Now consider:</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(struct Posn *p)</span></span>{
	<span class="hljs-keyword">int</span> temp = *p.x;
	*p.x = *p.y;
	*p.y = temp;
}
</div></code></pre>
<ul>
<li>STILL WRONG - Postfix before Prefix</li>
<li>Not even going to compile
<ul>
<li><code>*(p.x) = *(p.y)</code></li>
</ul>
</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(struct Posn *p)</span></span>{
	<span class="hljs-keyword">int</span> temp = (*p).x;
	(*p).x = (*p).y;
	(*p).y = temp;
}
</div></code></pre>
<p>They gave this it's own notation:</p>
<pre><code class="language-c"><div>p-&gt;x <span class="hljs-comment">// means (*p).x</span>
</div></code></pre>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(struct Posn *p)</span></span>{
	<span class="hljs-keyword">int</span> temp = p-&gt;x;
	p-&gt;x = p-&gt;y;
	p-&gt;y = temp;
}
</div></code></pre>
<h1 id="jan-5-pointersmutation-cont">Jan 5: Pointers/mutation Cont.</h1>
<p>Better input: scanf</p>
<pre><code class="language-c"><div><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, x);  
</div></code></pre>
<ul>
<li>reads in x as a decimal integer</li>
<li>skips leading whitespace</li>
<li>but, scanf is a function. You can't modify x</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;x);  
<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;x, &amp;y);
</div></code></pre>
<ul>
<li>space between <code>%d</code> -&gt; skip any whitespace between two <code>%d</code> (including no whitespace)</li>
<li>scanf has lots of options</li>
<li>Returns the number of arguments actually read</li>
</ul>
<h2 id="better-mutation-in-racket">Better mutation in Racket</h2>
<p>Mutating structures + lists</p>
<ul>
<li>in Scheme, you can mutate the parts of a cons with set-car! and set-cdr!</li>
<li>What does cons do? creates a pair <code>[address port | decrement port]</code>
<ul>
<li>you have car, cdr for that</li>
</ul>
</li>
<li>Change in racket:
<ul>
<li>cons fields are immutable: cannot be mutated</li>
</ul>
</li>
<li>for mutable pairs, racket provides <code>mcons</code></li>
<li>if you want to mutate a field, use <code>mset-car!, mset-cdr!</code></li>
<li>Structs, provide the option <code>#:mutable</code></li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name">struct</span> posn (<span class="hljs-name">x</span> y) #:mutable)
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> p (<span class="hljs-name">posn</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>))
(<span class="hljs-name">set-posn-x!</span> p <span class="hljs-number">5</span>)
(<span class="hljs-name">posn-x</span> p) =&gt; <span class="hljs-number">5</span>
</div></code></pre>
<p>you can also use <code>#:transparent</code> to see what's inside</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">struct</span> posn (<span class="hljs-name">x</span> y) #:mutable <span class="hljs-literal">#t</span>ransparent)
</div></code></pre>
<h3 id="semantics">Semantics</h3>
<ul>
<li>1A - (make-posn v1 v2) is a value</li>
<li>you can also use <code>#:transparent</code> to see what's inside</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name">struct</span> posn (<span class="hljs-name">x</span> y) #:mutable <span class="hljs-literal">#t</span>ransparent)

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">mutate-posn</span> p)
	(<span class="hljs-name">set-posn-x!</span> p (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">1</span> (<span class="hljs-name">posn-x</span> p))))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">mutate-posn2</span> p)
	(<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> p (<span class="hljs-name">posn</span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">1</span> (<span class="hljs-name">posn-x</span> p)) (<span class="hljs-name">posn-y</span> p))))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> p (<span class="hljs-name">posn</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> q (<span class="hljs-name">posn</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>))
(<span class="hljs-name">mutate-posn</span> p)
(<span class="hljs-name">mutate-posn2</span> q)
p -&gt; (<span class="hljs-name">posn</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>)
q -&gt; (<span class="hljs-name">posn</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>)
</div></code></pre>
<ul>
<li>But (make-posn v1 v2) cannot possibly be a value if it's mutable</li>
<li>has to behave like a box. but, the entire struct is not <strong>themselves</strong> a box, but they box their fields</li>
</ul>
<pre><code class="language-scheme"><div><span class="hljs-comment">; We can rewrite (posn v1 v2) as:</span>

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> _val1 v1)
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> _val2 v2)
(<span class="hljs-name">posn</span> _val1 _val2)
</div></code></pre>
<ul>
<li><code>(posn-x p)</code> where p is <code>(posn _val1 _val2)</code>
<ul>
<li>finds the definition for <code>_val1</code>, fetches the value.</li>
</ul>
</li>
<li><code>(set-posn-x! p v)</code> where <code>p = posn(_val1 _val2)</code>
<ul>
<li>find <code>(define _val1 v1)</code>, replace with <code>(define val1 v)</code></li>
</ul>
</li>
<li>Stepping:</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> p1 (<span class="hljs-name">posn</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>))
(<span class="hljs-name">set-posn-x!</span> p1 <span class="hljs-number">5</span>)
=&gt;  (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> _v1 <span class="hljs-number">3</span>)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> _v2 <span class="hljs-number">4</span>)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> p1 (<span class="hljs-name">posn</span> _v1 _v2))
	(<span class="hljs-name">set-posn-x!</span> p1 <span class="hljs-number">5</span>)
=&gt; 	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> _v1 <span class="hljs-number">3</span>)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> _v2 <span class="hljs-number">4</span>)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> p1 (<span class="hljs-name">posn</span> _v1 _v2))
	(<span class="hljs-name">set-posn-x!</span> (<span class="hljs-name">posn</span> _v1 _v2) <span class="hljs-number">5</span>)
=&gt; 	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> _v1 <span class="hljs-number">5</span>)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> _v2 <span class="hljs-number">4</span>)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> p1 (<span class="hljs-name">posn</span> _v1 _v2))
	(<span class="hljs-name">void</span>)
</div></code></pre>
<p>This generalizes to any mutable struct, mcons</p>
<p>consider:</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> lst1 (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name">box1</span>) empty))	// CONS NOT MUTABLE CONS
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> lst2 (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> <span class="hljs-number">2</span> lst1))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> lst2 (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> <span class="hljs-number">3</span> lst1))

(<span class="hljs-name">set-box!</span> (<span class="hljs-name">first</span> (<span class="hljs-name">rest</span> lst2)) <span class="hljs-number">4</span>)
(<span class="hljs-name">unbox</span> (<span class="hljs-name">first</span> (<span class="hljs-name">rest</span> lst3)))
</div></code></pre>
<p>By the 1A understanding, this should produce 1. but, this actually produces 4.</p>
<pre><code class="language-scheme"><div>lst<span class="hljs-number">2</span> = (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> <span class="hljs-number">2</span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name">box1</span>) empty))
lst<span class="hljs-number">3</span> = (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> <span class="hljs-number">3</span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name">box1</span>) empty))
</div></code></pre>
<p>but, the two box1's are the same object</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> lst2 (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> <span class="hljs-number">2</span> lst1))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> lst2 (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> <span class="hljs-number">3</span> lst1))
</div></code></pre>
<ul>
<li>Turns out, that this is two lists with the same tail</li>
<li>Need mutation to observe the effect</li>
</ul>
<p><strong>Aside:</strong></p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> lst1 (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> .... <span class="hljs-number">1000000</span>))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> lst2 (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> <span class="hljs-number">0</span> (<span class="hljs-name">rest</span> lst1)))
</div></code></pre>
<ul>
<li>we knew that cons, rest, first ran in constant time (FAST)</li>
<li>There's no way they created an entirely new list because there's no way to do that quickly</li>
</ul>
<p>in the old substitution rules, you get the answer 1
in the new substitution rules, boxes are rewritten as a separate define with deferred lookup</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> _val1 <span class="hljs-number">1</span>)
lst<span class="hljs-number">2</span> = (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> <span class="hljs-number">2</span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> _val1 empty))
lst<span class="hljs-number">3</span> = (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> <span class="hljs-number">3</span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> _val1 empty))

Both of these are clearly the same variable

</div></code></pre>
<h2 id="define">Define</h2>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> x <span class="hljs-number">3</span>) (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> x <span class="hljs-number">7</span>) x
=&gt; (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> x <span class="hljs-number">7</span>) (<span class="hljs-name">void</span>)) x
=&gt; (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> x <span class="hljs-number">7</span>) x
=&gt; <span class="hljs-number">7</span>
</div></code></pre>
<ul>
<li>
<p>You can't just replace all x with 3, or we would have gotten 3</p>
</li>
<li>
<p>x is not just a value, it's something we can mutate (an entity)</p>
</li>
<li>
<p>x denotes a location, and the location contains the value.</p>
</li>
<li>
<p>So, we don't just have one lookup. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span> : var -&gt; variable</p>
<ul>
<li>We have <em>Two</em> lookups : var <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> location, location <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> value</li>
</ul>
</li>
<li>
<p><code>set!</code> changes the location <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> value map, but not the var <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> location map</p>
</li>
<li>
<p>Similarly, set-box! changes the location <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> value mapping</p>
</li>
<li>
<p><code>(define ...)</code> crates a <em>location</em>, and fills it with a <em>value</em></p>
</li>
</ul>
<h2 id="back-to-c">Back to c</h2>
<p>consider</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">int</span> *y = &amp;x;
	<span class="hljs-keyword">int</span> *z = y;
	
	*z = <span class="hljs-number">2</span>;
	*z = <span class="hljs-number">3</span>;

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d %d\n"</span>, x, *y, *z);
}
</div></code></pre>
<p>Output:  3 3 3</p>
<ul>
<li>Why?</li>
<li>y is initialized to x's address (where x resides).</li>
<li>z is initialized to y which is the location of x</li>
<li>x, <code>*y, *z</code> are three different names for the same data</li>
<li>This is called aliasing</li>
<li>can be subtle:</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x, <span class="hljs-keyword">int</span> *y)</span></span>{
	*y = *x + <span class="hljs-number">1</span>; <span class="hljs-comment">// equivalent to += 1</span>
	<span class="hljs-keyword">if</span> (*y == *x){ <span class="hljs-comment">// true by def</span>
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"How can this ever print?\n"</span>);
	}
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> z = <span class="hljs-number">1</span>;
	f(&amp;z, &amp;z); <span class="hljs-comment">// x,y are aliases</span>
}
</div></code></pre>
<ul>
<li><code>*x and *y</code> are aliases so it does print.</li>
<li>aliasing with pointers makes programs very hard to understand</li>
</ul>
<h1 id="jan-7-memory-and-vectors">Jan 7: Memory and Vectors</h1>
<p><em>Recall:</em></p>
<ul>
<li>Memory is a set of numbered slots</li>
</ul>
<p><strong>32 bit ram (RAM)</strong></p>
<table>
<thead>
<tr>
<th>address</th>
<th>Contents</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1100111..</td>
</tr>
<tr>
<td>4</td>
<td>11000111..</td>
</tr>
<tr>
<td>8</td>
<td>1100101..</td>
</tr>
<tr>
<td>12</td>
<td>11001110.</td>
</tr>
<tr>
<td>..</td>
<td>..</td>
</tr>
<tr>
<td>256</td>
<td>1100011..</td>
</tr>
</tbody>
</table>
<p>Each slot is 8 bits (1 byte) , but they're usually labelled in groups of 4-byte words</p>
<h2 id="vectors">Vectors</h2>
<ul>
<li>Primitive data structure:
<ul>
<li>Array: &quot;Slice&quot; of memory, sequence of consecutive locations</li>
<li>Will discuss when we return to c</li>
<li>Racket(Scheme): the Vector (used like a traditional array)</li>
<li>Racket vectors can hold items of any size (unlimited integers, strings, whatever)</li>
</ul>
</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">vector</span></span> `blue true <span class="hljs-string">"you"</span>))

&gt; `#(<span class="hljs-name">blue</span> <span class="hljs-literal">#t</span> <span class="hljs-string">"you"</span>)
</div></code></pre>
<p>This a vector with any length and any width?</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> y (<span class="hljs-name"><span class="hljs-builtin-name">make-vector</span></span> <span class="hljs-number">100</span>)) 
// - creates a vector of length <span class="hljs-number">100</span>, all <span class="hljs-number">0</span>s
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> y (<span class="hljs-name"><span class="hljs-builtin-name">make-vector</span></span> <span class="hljs-number">100</span> <span class="hljs-number">5</span>)) 
// all <span class="hljs-number">5</span>s
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> y (<span class="hljs-name"><span class="hljs-builtin-name">make-vector</span></span> <span class="hljs-number">100</span> sqr)) =&gt; (<span class="hljs-name">0</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> ... <span class="hljs-number">99</span>^2)
(<span class="hljs-name"><span class="hljs-builtin-name">vector-ref</span></span> y <span class="hljs-number">7</span>)
// access element <span class="hljs-number">7</span> (<span class="hljs-name">will</span> produce <span class="hljs-number">5</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">vector-set!</span></span> y <span class="hljs-number">7</span> <span class="hljs-number">42</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">vector-ref</span></span> y <span class="hljs-number">7</span>) &gt;&gt; <span class="hljs-number">42</span>
</div></code></pre>
<ul>
<li>Access or mutate items by index</li>
</ul>
<p>Why use vectors?</p>
<ul>
<li>You don't need to walk through the list.</li>
<li>Fetching and storing <code>(vector-ref ) (vector-set! )</code> always runs in constant time O(1)</li>
<li>Disadvantages:
<ul>
<li>Size is fixed</li>
<li>Difficult to add or remove elements</li>
</ul>
</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">my-build-vector</span> n f)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> res (<span class="hljs-name"><span class="hljs-builtin-name">make-vector</span></span> n))
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">mbv-h</span> i)
		if (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> i n) res
		(<span class="hljs-name"><span class="hljs-builtin-name">begin</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">vector-set!</span></span> res i (<span class="hljs-name">f</span> i))
			(<span class="hljs-name">mbv-h</span> (<span class="hljs-name">add1</span> i))))

	(<span class="hljs-name">mbv-h</span> <span class="hljs-number">0</span>))
</div></code></pre>
<p>for, for/vector macros facilitate easy operations</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">my-build-vector</span> n f`))
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> res (<span class="hljs-name"><span class="hljs-builtin-name">make-vector</span></span> n))
	(<span class="hljs-name">for</span> ([<span class="hljs-name">i</span> n])
		(<span class="hljs-name"><span class="hljs-builtin-name">vector-set!</span></span> res i (<span class="hljs-name">f</span> i)))
	(<span class="hljs-name">res</span>)
)
or 
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">my-build-vector</span> n f)
	(<span class="hljs-name">for/vector</span> ([<span class="hljs-name">i</span> n]) (<span class="hljs-name">f</span> i)))
</div></code></pre>
<p>eg: Sum of elements of a vector</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">sum-vector</span> vec)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">sv-h</span> i acc)
		(<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> 	[(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> i (<span class="hljs-name"><span class="hljs-builtin-name">vector-length</span></span> vec)) acc]
				[<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">sv-h</span> (<span class="hljs-name">add1</span> i)
							(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> acc (<span class="hljs-name"><span class="hljs-builtin-name">vector-ref</span></span> vec i)))]))
	(<span class="hljs-name">sv-h</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>))


(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">sum-vec</span> vc)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> sum <span class="hljs-number">0</span>)
	(<span class="hljs-name">for</span> [(<span class="hljs-name">i</span> (<span class="hljs-name"><span class="hljs-builtin-name">vector-length</span></span> vec))]
		(<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> sum (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> sum (<span class="hljs-name"><span class="hljs-builtin-name">vector-ref</span></span> vec i))))
	sum)
</div></code></pre>
<ul>
<li>Note: the first one is pure functional but the second is not (uses mutation)</li>
<li>but, it &quot;Looks&quot; pure functional because mutations are confined within the function</li>
<li>Outsiders can consider it pure functional</li>
<li>Provides a strategy for keeping problems with mutation under control</li>
<li>Hide it under pure functional interface</li>
</ul>
<p>Notes:</p>
<ul>
<li>Memory slots also only hold fixed size data</li>
<li>What are unlimited numbers? strings?</li>
</ul>
<p>Recall:</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">struct</span> posn (<span class="hljs-name">x</span> y) #:mutable <span class="hljs-literal">#t</span>ransparent)

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">mutate-posn</span> p)
	(<span class="hljs-name">set-posn-x!</span> p (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">1</span> (<span class="hljs-name">posn-x</span> p))))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> q (<span class="hljs-name">posn</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>))
(<span class="hljs-name">mutate-posn</span> p)
(<span class="hljs-name">posn-x</span> p) =&gt; <span class="hljs-number">4</span>
</div></code></pre>
<p>in C:</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mutate</span><span class="hljs-params">(struct Posn p)</span></span>{
	p.x += <span class="hljs-number">1</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Posn</span> <span class="hljs-title">p</span> = {</span><span class="hljs-number">3</span>,<span class="hljs-number">5</span>};
	mutate(p);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, p.x)
}
</div></code></pre>
<ul>
<li>Racket structs are copied, but changes to the field still persist</li>
<li>Fields of a racket struct are <strong>Boxed</strong>. they're pointers.</li>
</ul>
<p>Similarly, the items in a Racket vector are addresses that point to the actual contents (which can be any size)</p>
<p>Similarly, the field of a cons are pointers:</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> <span class="hljs-number">1</span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> `blue (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> true empty)))
</div></code></pre>
<p>Box and pointer diagram (INSERT HERE LOL )</p>
<p>Since racket is dynamically typed, the values l, 'blue, true must include type information. More on that later</p>
<h1 id="vectors-in-c-arrays">Vectors in C: Arrays</h1>
<p>Array:  A sequence of consecutive memory locations</p>
<p>eg:</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> grades[<span class="hljs-number">10</span>]; <span class="hljs-comment">// array of 10 ints</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i){
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;grades[i]);
	}
	<span class="hljs-keyword">int</span> acc = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) acc += grades[i];
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span> acc/<span class="hljs-number">10</span>);
}
</div></code></pre>
<p>a[i] accesses the i'th element of the array a</p>
<pre><code class="language-c"><div><span class="hljs-keyword">int</span> grades[<span class="hljs-number">10</span>]; 
</div></code></pre>
<ul>
<li>What happens if you go out of bounds? grades[11]
<ul>
<li>No one knows!</li>
<li>Will it stop you? No. The program <strong>may or may not crash</strong></li>
<li>So your data might be corrupted, and you won't know</li>
</ul>
</li>
</ul>
<p>You can give the bound implicitly</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> grades[] = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%zd\n"</span>, <span class="hljs-keyword">sizeof</span>(grades) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
}
</div></code></pre>
<p>}</p>
<h1 id="feb14-arrays-continued">Feb14: Arrays Continued</h1>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> grades[] = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%zd\n"</span>, <span class="hljs-keyword">sizeof</span>(grades) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
}
</div></code></pre>
<ul>
<li><code>sizeof</code> is evaluated by the compiler. At compile-time, the compiler substitutes the actual size of the item (which the compiler obviously knows) in place of the sizeof expression.
<ul>
<li><code>sizeof(grades)</code> : Amount of memory 'grades' occupies (20 bytes)</li>
<li><code>sizeof(int)</code> : amount of space an int occupies (4 bytes)</li>
</ul>
</li>
<li>type <code>size_t</code>, unsigned
<ul>
<li><code>#include &lt;stddef.h&gt;</code></li>
<li>sizeof always is big enough to hold the number. %d might not be able to handle it. The <code>%zd</code> states that we're going to be printing a size_t</li>
</ul>
</li>
</ul>
<p>Functions on Arrays:</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> size)</span></span>{
	<span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) res += arr[i];
	<span class="hljs-keyword">return</span> res;
}
</div></code></pre>
<ul>
<li>Note that we passed an array to this boi (BY VALUE) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> We copy the whole array, and that's really expensive</li>
<li>C will not pass arrays by value</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> myArray[<span class="hljs-number">100</span>];
	<span class="hljs-keyword">int</span> total = sum(myArray, <span class="hljs-number">100</span>)
}
</div></code></pre>
<ul>
<li>Most confusing rule in all of c</li>
<li>Name of an array is shorthand for a pointer to the first element</li>
<li>myArray is shorthand for &amp;myArray[0]</li>
<li>therefore, (myArray, 100) passes a pointer, not a whole array, into the function.</li>
<li>Sum is expecting an array, not a pointer.</li>
<li>Why not an int <code>sum(int *arr, int size)</code>?</li>
<li>Turns out int <code>int *arr</code> and <code>int arr[]</code> are exactly the same in <em>parameter specifications</em></li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> size)</span></span>{
	<span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) res += arr[i];
	<span class="hljs-keyword">return</span> res;
}
</div></code></pre>
<h2 id="pointer-arithmetic">Pointer Arithmetic</h2>
<p>Let t be a type.</p>
<pre><code class="language-c"><div>t arr[<span class="hljs-number">10</span>];

<span class="hljs-keyword">sizeof</span>(arr) = <span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(t)

</div></code></pre>
<ul>
<li><code>arr</code> is shorthand for <code>&amp;arr[0]</code></li>
<li><code>*arr</code> is equivalent to <code>arr[0]</code></li>
<li>What produces the pointer to <code>arr[1]</code>?</li>
<li><code>arr + 1</code> is shorthand for <code>&amp;arr[1]</code></li>
<li><code>arr + 2</code> is shorthand for <code>&amp;arr[2]</code></li>
<li>Numerically, <code>arr + n</code>
is the address equal to <code>arr + n * sizeof(t)</code></li>
</ul>
<p>Therefore, sum is equivalent to</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> size)</span></span>{
	<span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) res += *(arr + i);
	<span class="hljs-keyword">return</span> res;
}
</div></code></pre>
<p>In fact, <code>a[k]</code> is shorthand for <code>*(a+k)</code></p>
<p><code>a[k] = *(a + k) = *(k + a) = k[a]</code></p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> size)</span></span>{
	<span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> *cur = arr; cur &lt; arr + size; ++cur) res += *cur;
}
</div></code></pre>
<ul>
<li>note:
<ul>
<li><code>arr + size</code> is one past the end of the array (ok as long as you don't dereference)</li>
<li>Pointer comparison can compare if they point to the same array (or one past the end)</li>
</ul>
</li>
<li>Any pointer can be thought of as pointing to the beginning of an array. You can use <code>a[0]</code> instead of <code>*a</code>
<ul>
<li>same syntax for accessing an item through an array as through a pointer</li>
<li>Are arrays and pointers the same thing? NO.</li>
</ul>
</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span></span>{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%zd\n"</span>, <span class="hljs-keyword">sizeof</span>(arr));
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> myArray[<span class="hljs-number">10</span>];
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%zd\n"</span>, <span class="hljs-keyword">sizeof</span>(myArray));
	f(myArray);
}

Outputs: 
<span class="hljs-number">40</span>
<span class="hljs-number">8</span>
</div></code></pre>
<p>First time, you print the size of the array (4 int * 10) -&gt; second time it's the size of the pointer (always 8)</p>
<p>Ram:</p>
<pre><code><div> _________
|_________| - arr points to myArray
|_________|
|_________|
|_________| ]
|_________|	]
|_________|	]   myArray
|_________|	]
|_________|	]
|_________|	
|_________|	
</div></code></pre>
<ul>
<li>Compiler: <code>myArray[i]</code>
<ul>
<li>fetch <code>myArray</code> location from env 	// compile time</li>
<li>add <code>i * sizeof(int)</code>					// run time</li>
<li>fetch addr from store 				// run time</li>
</ul>
</li>
<li><code>arr[i]</code>
<ul>
<li>fetch <code>arr</code> location from env 			// compile time</li>
<li>fetch <code>myArray addr</code> from store.		// run time</li>
<li>add <code>i * sizeof(int)</code> to addr 			// run time</li>
<li>Fetch the item from the store 		// run time</li>
</ul>
</li>
</ul>
<p>-<code>myArray[i]</code> and <code>arr[i]</code> are slightly different</p>
<p>We saw the racket struct <code>(struct posn (x y))</code> is like a c struct whose fields are pointers. How can we achieve this in C?</p>
<pre><code class="language-c"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Posn</span>{</span>
	<span class="hljs-keyword">int</span> *x;
	<span class="hljs-keyword">int</span> *y;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Posn</span> <span class="hljs-title">p</span>;</span>
	<span class="hljs-comment">// what are p.x and p.y pointing at?</span>
	*p.x = <span class="hljs-number">3</span>;
	*p.y = <span class="hljs-number">4</span>;
}
</div></code></pre>
<ul>
<li>
<p>This won't run becuase <code>p.x</code>, <code>p.y</code> doesn't actually point to anything</p>
</li>
<li>
<p>Point at arbitrary locations, dictated by whatever values they happen to hold</p>
</li>
<li>
<p>so (posn 3 4) must also reserve memory for x + y to point at, to hold the 3 + 4</p>
</li>
</ul>
<p>Ram:</p>
<pre><code><div>
		|_________|
		|_________|
p	x   |?????????| -&gt; ??????	
	y 	|?????????| -&gt; ????????
		|_________|
		|_________|
		|		  |
	
</div></code></pre>
<pre><code class="language-c"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-function">struct Posn <span class="hljs-title">makePosn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Posn</span> <span class="hljs-title">p</span>;</span>
	p.x = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)) 
	p.y = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>))
	*p.x = x;
	*p.y = y;
	<span class="hljs-keyword">return</span> p
}
</div></code></pre>
<p><code>malloc(n)</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> request n bytes of memory</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Posn</span> <span class="hljs-title">p</span> = <span class="hljs-title">makePosn</span>(3,4);</span>
	...
}
</div></code></pre>
<p>Need to understand exactly what's happening</p>
<p>\newpage</p>
<h1 id="feb-26-memory-model">Feb 26: Memory Model</h1>
<table>
<thead>
<tr>
<th>RAM</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>CODE</td>
<td>Your program's binary code</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>STATIC</td>
<td></td>
</tr>
<tr>
<td>---</td>
<td></td>
</tr>
<tr>
<td>HEAP</td>
<td>Your program's data</td>
</tr>
<tr>
<td>---</td>
<td></td>
</tr>
<tr>
<td>STACK</td>
<td></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<h2 id="static">Static:</h2>
<ul>
<li>Where global/static variables are stored</li>
</ul>
<h2 id="stack-area">Stack Area:</h2>
<ul>
<li>holds local variables</li>
<li>lifetime: the entire program</li>
<li>What is a stack?</li>
<li>an ADT with LIFO semantics
<ul>
<li>LIFO : Last In first Out</li>
<li>Can only remove the most recently-inserted item</li>
</ul>
</li>
<li>Operations:
<ul>
<li>Push 	: add an item to the stack</li>
<li>Top 	: What is the most recently added item?</li>
<li>Pop 	: Remove the most recently added item</li>
<li>Empty?: Is the stack empty?</li>
</ul>
</li>
<li>This is a racket list!
<ul>
<li>Push = cons</li>
<li>Pop = rest</li>
<li>Top = first</li>
<li>Empty? = empty?</li>
</ul>
</li>
</ul>
<pre><code class="language-c"><div>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{
	<span class="hljs-keyword">int</span> rec = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	rec = fact(n<span class="hljs-number">-1</span>)
	<span class="hljs-keyword">return</span> n * rec;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> f = fact(<span class="hljs-number">3</span>);
}
</div></code></pre>
<p>What's happening?</p>
<p>Note that whenever a function is called, you need to know where the function returns to. Recursive calls of fact return to another fact, but the first call returns to main.</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>fact</td>
<td>rec : 0, n : 0, ret: fact</td>
</tr>
<tr>
<td>fact</td>
<td>rec : 0, n : 1, ret: fact</td>
</tr>
<tr>
<td>fact</td>
<td>rec: 0, n : 2	, ret: fact</td>
</tr>
<tr>
<td>fact</td>
<td>rec : 0, n : 3, ret: main</td>
</tr>
<tr>
<td>main</td>
<td>f:</td>
</tr>
</tbody>
</table>
<p>On the way back...</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td><s>fact</s></td>
<td><s>rec : 0, n : 0, ret: fact</s></td>
</tr>
<tr>
<td><s>fact</s></td>
<td><s>rec : 0 -&gt; 1, n : 1, ret: fact</s></td>
</tr>
<tr>
<td><s>fact</s></td>
<td><s>rec: 0 -&gt; 1, n : 2	, ret: fact</s></td>
</tr>
<tr>
<td><s>fact</s></td>
<td><s>rec : 0 -&gt; 2, n : 3, ret: main</s></td>
</tr>
<tr>
<td>main</td>
<td>f:	6</td>
</tr>
</tbody>
</table>
<p>Note:</p>
<ul>
<li>Local vars are pushed onto the stack, also the return address (where to go when the function returns)</li>
<li>Grows on call, shrinks on return. This is a stack</li>
<li>Each function call gets a <strong>Stack Frame</strong></li>
<li>Each invocation of a function gets it's own version of local vars</li>
<li>When a function returns, it's stack frome is popped
<ul>
<li>all local vars in that frame are released</li>
<li>not typically erased</li>
<li>&quot;top of stack&quot; ptr moved to the next frame</li>
<li>will be overwritten next time a frame is pushed onto the stack</li>
</ul>
</li>
</ul>
<p><strong>eg: what's wrong with</strong></p>
<pre><code class="language-c"><div><span class="hljs-function">struct Posn <span class="hljs-title">makePosn</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Posn</span> <span class="hljs-title">p</span>;</span>
	<span class="hljs-keyword">int</span> a = x;
	<span class="hljs-keyword">int</span> b = y;
	p.x = &amp;a;
	p.y = &amp;b;
	<span class="hljs-keyword">return</span> p;
}
</div></code></pre>
<ul>
<li>This is different from the last time. P's x and y are actually pointing at real memory locations</li>
<li>once these variables go out of scope, you're screwed. they're going to be re-written</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Posn</span> <span class="hljs-title">p</span> = <span class="hljs-title">makePosn</span> (3, 4);</span>
}
</div></code></pre>
<table>
<thead>
<tr>
<th></th>
<th>ram</th>
</tr>
</thead>
<tbody>
<tr>
<td>P.x</td>
<td>-&gt; a</td>
</tr>
<tr>
<td>P.Y</td>
<td>-&gt; b</td>
</tr>
<tr>
<td>a</td>
<td>3</td>
</tr>
<tr>
<td>b</td>
<td>4</td>
</tr>
<tr>
<td>ret</td>
<td>ret</td>
</tr>
<tr>
<td>main P</td>
<td></td>
</tr>
</tbody>
</table>
<p>After return,</p>
<table>
<thead>
<tr>
<th></th>
<th>ram</th>
</tr>
</thead>
<tbody>
<tr>
<td><s>P.x</s></td>
<td><s>-&gt; a</s></td>
</tr>
<tr>
<td><s>P.Y</s></td>
<td><s>-&gt; b</s></td>
</tr>
<tr>
<td><s>a</s></td>
<td><s>3</s></td>
</tr>
<tr>
<td><s>b</s></td>
<td><s>4</s></td>
</tr>
<tr>
<td><s>ret</s></td>
<td><s>ret</s></td>
</tr>
<tr>
<td>main P.x</td>
<td>-&gt; P.x</td>
</tr>
<tr>
<td>main P.y</td>
<td>-&gt; p.y</td>
</tr>
</tbody>
</table>
<ul>
<li>Returned P contains pointers to local stack allocated data. DO not do this. It will not crash.</li>
</ul>
<h2 id="heap">Heap</h2>
<ul>
<li>Malloc requests memory from the heap.</li>
<li>The heap is a pool of memory from which you can request chunks</li>
<li>Lifetime of STACK memory is until the variable of the scope ends (eg: end of function)</li>
<li>Lifetime of HEAP memory is arbitrary</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function">struct Posn <span class="hljs-title">makePosn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Posn</span> <span class="hljs-title">p</span>;</span>				<span class="hljs-comment">// on stack</span>
	p.x = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));	<span class="hljs-comment">// on heap</span>
	p.y = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));	<span class="hljs-comment">// on heap</span>
	*p.x = x;
	*p.y = y;	
	<span class="hljs-keyword">return</span> p;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Posn</span> <span class="hljs-title">p</span> = <span class="hljs-title">makePosn</span>(3,4);</span>
}
</div></code></pre>
<table>
<thead>
<tr>
<th>mem</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>When makePosn returns:
<ul>
<li>when makeposn returns, p (including p.x and p.y) are popped off the stack</li>
<li>3 + 4 on the heap are still live.</li>
<li>p from make-Posn copied back to main frame</li>
</ul>
</li>
<li>Main has access to 3 + 4 on the heap, these outline makePosn</li>
<li>Racket does the same thing</li>
<li>But what is the lifetime of heap-allocated data? arbitrarily long</li>
<li>If it never goes away, program will eventually run out of memory, even if the data is no longer in use</li>
</ul>
<h3 id="rackets-solution">Racket's Solution:</h3>
<ul>
<li>run-time processing detects memory that is no longer accessible, and automatically reclaims it (Garbage Collection)</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">f</span> x)
	(<span class="hljs-name">local</span> [(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> p (<span class="hljs-name">posn</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>))]
		...
		(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> x <span class="hljs-number">1</span>)))
</div></code></pre>
<ul>
<li>(posn 3 4) not needed anymore</li>
</ul>
<h3 id="cs-solution">C's Solution</h3>
<ul>
<li>Heap memory is freed when you free it!</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-keyword">int</span> *p = <span class="hljs-built_in">malloc</span>();
<span class="hljs-built_in">free</span>(p);
</div></code></pre>
<ul>
<li>If you fail to free all allocated memory, that's a memory leak.</li>
<li>Programs that leak tend to fail (when they run long enough)</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-keyword">int</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
<span class="hljs-built_in">free</span>(p);
*p = <span class="hljs-number">7</span>; <span class="hljs-comment">// will this crash?</span>
</div></code></pre>
<ul>
<li>Probably not.</li>
<li>free(p) does not change p</li>
<li>but p is not pointing to a valid location
<ul>
<li>That location may be assigned to another ptr by malloc call</li>
<li>this is a dangling pointer -&gt; BAD.</li>
</ul>
</li>
<li>Better: after free(p), assign p to be a nullptr (Guaranteed invalid location)</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-keyword">int</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
<span class="hljs-built_in">free</span>(p);
p = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// null ptr -&gt; points to nothing</span>
</div></code></pre>
<ul>
<li><strong>NULL</strong>
<ul>
<li>Not really a part of the c language</li>
<li>defined as a constant equal to 0</li>
<li>could equally say p = 0;</li>
</ul>
</li>
<li>Dereferencing NULL -&gt; undefined behaviour
<ul>
<li>May crash. (Probably will?)</li>
</ul>
</li>
</ul>
<p><em>NEVER</em> return a pointer to a local variable. If you want to return a pointer, it should point to the static, heap, or non-local stack data.</p>
<pre><code class="language-c"><div><span class="hljs-comment">// nonlocal stack data:</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pickOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x, <span class="hljs-keyword">int</span> *y)</span></span>{
	<span class="hljs-keyword">return</span> _____ ? x : y;
}

<span class="hljs-comment">// Heap</span>
<span class="hljs-function">struct Posn *<span class="hljs-title">getMeAPtr</span><span class="hljs-params">()</span></span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Posn</span> *<span class="hljs-title">p</span> = <span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Posn</span>));</span>
	<span class="hljs-keyword">return</span> p;
}

<span class="hljs-comment">// Static</span>
<span class="hljs-keyword">int</span> z = <span class="hljs-number">5</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">f</span><span class="hljs-params">()</span></span>{<span class="hljs-keyword">return</span> &amp;z}
</div></code></pre>
<p>When should you use the heap?</p>
<ol>
<li>
<p>For data that should outlive the function that creates it</p>
</li>
<li>
<p>For data who's size is not known at compile time</p>
</li>
<li>
<p>for large local arrays</p>
</li>
<li>
<p>As a bove</p>
</li>
<li>
<p><code>int *p malloc(sizeof(int));</code></p>
<ul>
<li>Not that useful, why not <code>int n</code></li>
<li>But what if we ask for more memory?</li>
</ul>
</li>
</ol>
<pre><code class="language-c"><div><span class="hljs-keyword">int</span> numSlotsNeeded;
<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;numSlotsNeeded);
<span class="hljs-keyword">int</span> *p = <span class="hljs-built_in">malloc</span>(numSlotsNeeded * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>))
<span class="hljs-comment">// can access p[0]..., p[numSlotsNeeded-1];</span>
<span class="hljs-comment">// Dynamic array (heap allocated)</span>
<span class="hljs-built_in">free</span>(p)
</div></code></pre>
<ol start="3">
<li>Programs typically have more heap memory available than stack memory</li>
</ol>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">recursiveFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{
	...
	tempArray[<span class="hljs-number">10000000</span>];	<span class="hljs-comment">// uses up stack space for each recursive call</span>
	recursiveFunction(n);
}
</div></code></pre>
<ul>
<li>C arrays mimic racket vectors. Can we get the behaviour of a racket list?</li>
<li><code>(cons x y) -&gt; produces a pair (x,y)</code></li>
</ul>
<p>Recall, Racket is dynamically typed. c cons would need to be the same type.</p>
<h1 id="missed-feb-27">Missed Feb 27</h1>
<h1 id="feb-28-adt">Feb 28 ADT</h1>
<p>Recall: ADT Map / Dictionary</p>
<p>Implementation:</p>
<ul>
<li>assoc. list? -&gt; linear time lookups</li>
<li>BST - same worst case running time</li>
<li>Balanced BST (AUL Tree)
<ul>
<li>Significantly faster -&gt; log(n) instead of n, difficult implementation</li>
</ul>
</li>
<li>If we use vectors instead, O(1) for any access, but you can't make vectors bigger
<ul>
<li>Size is the max key? Wastes space</li>
</ul>
</li>
<li>Combine the two - vector of association lists
<ul>
<li>Hash table</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>(1, ) -&gt; (31, ) -&gt; (21,/)</td>
</tr>
<tr>
<td>1</td>
<td>(643, ) -&gt; (83,/)</td>
</tr>
<tr>
<td>2</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
</tr>
<tr>
<td>...</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="racket">Racket</h2>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">create-hashtable</span> size) (<span class="hljs-name"><span class="hljs-builtin-name">make-vector</span></span> size empty))
</div></code></pre>
<ul>
<li>To which association list should we add (k,v)?</li>
<li>Need to map k to a vector index
<ul>
<li>mapping called a <strong>hash function</strong></li>
<li>for simplicity, use the remainder of k by the length of the vector</li>
</ul>
</li>
<li>For this to work well, the hash function must distribute keys EVENLEY over the indices
<ul>
<li>Mod n doesn't work too well -&gt; only really works if the keys are evenly distributed. What if all keys end in 1? Worse than assoc list since unsorted</li>
<li>Not going to cover now</li>
</ul>
</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">ht-search</span> table key)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> index (<span class="hljs-name"><span class="hljs-builtin-name">modulo</span></span> key (<span class="hljs-name"><span class="hljs-builtin-name">vector-length</span></span> table)))
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> hashlist (<span class="hljs-name"><span class="hljs-builtin-name">vector-ref</span></span> table index))
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> lookup (<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> key hashlist))
	(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> lookup (<span class="hljs-name">second</span> lookup) false))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">ht-add</span> table key val)
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> index (<span class="hljs-name"><span class="hljs-builtin-name">modulo</span></span> key (<span class="hljs-name"><span class="hljs-builtin-name">vector-length</span></span> table)))
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> hashlist (<span class="hljs-name"><span class="hljs-builtin-name">vector-ref</span></span> table index))
	(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> lookup (<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> key hashlist))
	(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> lookup
		(<span class="hljs-name"><span class="hljs-builtin-name">when</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">not</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">equal?</span></span> (<span class="hljs-name">second</span> lookup) val))
			(<span class="hljs-name"><span class="hljs-builtin-name">vector-set!</span></span> table index (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> key val)
											(<span class="hljs-name">remove</span> lookup hashlist))))
		(<span class="hljs-name"><span class="hljs-builtin-name">vector-set!</span></span> table index (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> key val) hashlist))))
</div></code></pre>
<p>if keys aren't numbers, turn them into numbers.</p>
<ul>
<li>This isn't actually constant time.</li>
<li>What if we can guarantee the size of a table is some constant * #items</li>
<li>
<h1 id="items--size-of-table--constant">items / size of table = constant.</h1>
</li>
<li>If you go above the amount of designed input, you lose out.</li>
</ul>
<h2 id="c">C</h2>
<ul>
<li>C doesn't have modules, C has files.</li>
<li>implement ADT sequence in C</li>
<li>Operations:
<ul>
<li>empty sequence</li>
<li><code>insert(s, i, e)</code> // insert e at index i in s. Pre: i &lt;= size(s)
<ul>
<li>no mention of the sequence being full. Want infinite size. (Can grow as needed)</li>
</ul>
</li>
<li><code>size(s)</code> // # elements in s</li>
<li><code>remove(s, i)</code> // remove the i'th element from s</li>
<li><code>index(s,i)</code> // returns i'th element of s. pre: 0 &lt;= i &lt;= size(s) - 1</li>
</ul>
</li>
<li>Implementation options:
<ul>
<li>Linked List
<ul>
<li>easy to grow, slow to index</li>
</ul>
</li>
<li>Array
<ul>
<li>fast to index, hard to grow</li>
</ul>
</li>
<li>Approach: Partially filled heap array</li>
</ul>
</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-comment">//----------------------</span>
<span class="hljs-comment">// sequence.h</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sequence</span>{</span>
	<span class="hljs-keyword">int</span> size, *theArray, cap;
};

<span class="hljs-function">struct Sequence <span class="hljs-title">emptySeq</span><span class="hljs-params">()</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">seqSize</span><span class="hljs-params">(struct Sequence s)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(struct Sequence *s, <span class="hljs-keyword">int</span> e, <span class="hljs-keyword">int</span> i)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(struct Sequence *s, <span class="hljs-keyword">int</span> i)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">index</span><span class="hljs-params">(struct Sequence s, <span class="hljs-keyword">int</span> i)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeSequence</span><span class="hljs-params">(struct Sequence *s)</span></span>;

<span class="hljs-comment">//----------------------</span>
<span class="hljs-comment">// sequence.c</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"sequence.h"</span></span>

<span class="hljs-function">struct Sequence <span class="hljs-title">emptySeq</span><span class="hljs-params">()</span></span>{
	Struct Sequence res;
	res.size = <span class="hljs-number">0</span>;
	res.theArray = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
	res.cap = <span class="hljs-number">10</span>;
	<span class="hljs-keyword">return</span> res;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">seqSize</span><span class="hljs-params">(struct Sequence s)</span> </span>{<span class="hljs-keyword">return</span> s.size}

<span class="hljs-keyword">void</span> add(struct Sequence *s, <span class="hljs-keyword">int</span> e, <span class="hljs-keyword">int</span> i){
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = s-&gt;size; n &gt; i; --n){
		s-&gt;theArray[n] = s-&gt;theArray[n<span class="hljs-number">-1</span>];
	}
	++s-&gt;size;
	s-&gt;theArray[i] = e
}

<span class="hljs-comment">// remove as an exercise, same as add pretty much</span>

<span class="hljs-keyword">int</span> index(struct Sequence s, <span class="hljs-keyword">int</span> i){<span class="hljs-keyword">return</span> s.theArray[i]}

<span class="hljs-comment">// free seq as an exercise</span>

<span class="hljs-comment">//----------------------</span>
<span class="hljs-comment">// main.c</span>
#include <span class="hljs-string">"sequence.h"</span>

<span class="hljs-keyword">int</span> main(){
	struct Sequence s = emptySeq();
	add(s,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>);
	add(s,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>);

	<span class="hljs-comment">// ok but not immune to tampering</span>
	s.size = <span class="hljs-number">9</span> <span class="hljs-comment">// tampering!</span>
	struct Sequence t;
	t.size = <span class="hljs-number">10</span>;
	t.cap = <span class="hljs-number">20</span>;
}
</div></code></pre>
<ul>
<li>can we prevent this? Keep the details of struct sequence hidden.</li>
<li>declare but not define the struct?</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-comment">// sequence.h:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sequence</span>;</span>
<span class="hljs-function">struct Sequence <span class="hljs-title">emptySeq</span><span class="hljs-params">()</span></span>;
...
<span class="hljs-comment">// -------------------------------</span>
<span class="hljs-comment">//sequence.c</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"sequence.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sequence</span>{</span>
	<span class="hljs-keyword">int</span> size, cap, *theArray;
}
<span class="hljs-comment">// -------------------------------</span>
<span class="hljs-comment">// main.c</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"sequence.h"</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sequence</span> <span class="hljs-title">s</span>;</span>
	...
}
</div></code></pre>
<ul>
<li>Main doesn't know what Sequence is -&gt; has to call the functions right?</li>
<li>This won't compile
<ul>
<li>You compile main, then sequence, then link them together. They are seperate</li>
<li>I don't know how big struct Sequence is, so I can't put it on the stack.</li>
<li>Need to give it a size</li>
</ul>
</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-comment">// sequence.h:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SeqImpl</span>;</span>
<span class="hljs-keyword">typedef</span> SeqImpl *Sequence;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Sequence s, <span class="hljs-keyword">int</span> e, <span class="hljs-keyword">int</span> i)</span></span>;
...
<span class="hljs-comment">// -------------------------------</span>
<span class="hljs-comment">//sequence.c</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"sequence.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sequence</span>{</span>
	<span class="hljs-keyword">int</span> size, cap, *theArray;
}
...
<span class="hljs-comment">// -------------------------------</span>
<span class="hljs-comment">// main.c</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"sequence.h"</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	Sequence s;		<span class="hljs-comment">// ptr -&gt; ok! we know what a pointer's size is.</span>
	...
}
</div></code></pre>
<ul>
<li>
<p>typedef always looks like a variable declaration</p>
<ul>
<li><code>SeqImpl *x</code> -&gt; <code>typedef SeqImpl *NAME YOU WANT</code></li>
</ul>
</li>
<li>
<p>What happens if the array is full?</p>
</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Sequence s, <span class="hljs-keyword">int</span> e, <span class="hljs-keyword">int</span> i)</span></span>{
	<span class="hljs-keyword">if</span> (s.size == s.cap){
		<span class="hljs-comment">// make the array bigger</span>
		s-&gt;theArray = <span class="hljs-built_in">realloc</span>(s-&gt;theArray, NEW SIZE);
		...
	}
	...
}
</div></code></pre>
<ul>
<li><strong>Realloc</strong>
<ul>
<li>increases the block of memory to a new size</li>
<li>if necessary, allocates a new block and frees the old block</li>
</ul>
</li>
<li>How big should we make the new array?
<ul>
<li>Must assume realloc causes a copy O(n)</li>
<li>If we have a sequence of adds (at the end, so no shuffling cost)</li>
<li>#steps is n + n+1 + n+2 + n+3 + ... + n+k
= (k+1)n + k(k+1)/2 = O(kn + k^2) total cost</li>
<li>O(n+k) per add</li>
<li>Changing how much you add does not change the total O() (eg: increase by 10 each time)</li>
</ul>
</li>
<li>What if we double the size?
<ul>
<li>doesn't affect worst case -&gt; each add is still O(n) worst case.</li>
<li>But, <strong>Amortized Analysis</strong>.
<ul>
<li>Places a bound on the <strong>sequence</strong> of operations, even if an individual operation may be expensive</li>
<li>If an array has a cap of n and is empty,
<ul>
<li>n inserts cost O(1) each</li>
<li>1 insert costs O(n) - cap now 2n.</li>
<li>Get n-1 cost  O(1)</li>
<li>1 insert costs O(2n) - cap now 4n</li>
<li>2n-1 insert cost O(1)</li>
<li>1 insert costs o(4n) - cap now 8n</li>
</ul>
</li>
<li>Total Operations: 11n-2. Total 4n+1 Insertions. Cost per insertion: 11n-2 / 4n+1 ~ 11/4 = O(1)</li>
</ul>
</li>
<li>Doubling capacity is O(1) amortized time.
<ul>
<li>Eg: Queue from Midterm with two lists</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-c"><div>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">increaseCap</span><span class="hljs-params">(Sequence s)</span></span>{
	<span class="hljs-keyword">if</span> (s-&gt;size == s-&gt;cap){
		s-&gt;theArray = <span class="hljs-built_in">realloc</span>(s-&gt;theArray, <span class="hljs-number">2</span> * s-&gt;cap);
		s-&gt;cap *= <span class="hljs-number">2</span>;
	}
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(sequence s, <span class="hljs-keyword">int</span> e, <span class="hljs-keyword">int</span> i)</span></span>{
	increaseCap(s);
	<span class="hljs-comment">// as before</span>
}
</div></code></pre>
<ul>
<li>Helper Function: increaseCap - But, main should not be calling this. How do we prevent that? Leave it out of the the .h file
<ul>
<li>What if main declares it's own header?</li>
</ul>
</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"sequence.h"</span></span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">increaseCap</span><span class="hljs-params">(Sequence s)</span></span>;
</div></code></pre>
<ul>
<li>In sequence.c, we can use:
<ul>
<li>Only visible in this file</li>
<li>Prevents other from having access, even if they have their own function prototype</li>
</ul>
</li>
</ul>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increaseCap</span><span class="hljs-params">(Sequence s)</span></span>{...}
</div></code></pre>
<h1 id="march-5th-interpreting-mutation">March 5th: Interpreting Mutation</h1>
<ul>
<li>Recall:
<ul>
<li>The deferred substitution intepreter in haskell for faux racket</li>
</ul>
</li>
</ul>
<p>Haskell interpreter:</p>
<pre><code class="language-haskell"><div><span class="hljs-title">exp</span> = number
	| (op exp exp)
	| (fun (id) exp)
	| (with ((id exp)) exp)
	| (exp exp)
	| id

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Op</span> = <span class="hljs-type">Plus</span>/<span class="hljs-type">Times</span></span>
<span class="hljs-title">opTrans</span> <span class="hljs-type">Plus</span> = (+)
<span class="hljs-title">opTrans</span> <span class="hljs-type">Times</span> = (*)

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Ast</span> = 	<span class="hljs-type">Number</span> <span class="hljs-type">Integer</span> 	| <span class="hljs-type">Bin</span> <span class="hljs-type">Op</span> <span class="hljs-type">Ast</span> <span class="hljs-type">Ast</span> | <span class="hljs-type">Fun</span> <span class="hljs-type">String</span> <span class="hljs-type">Ast</span></span>
			| <span class="hljs-type">App</span> <span class="hljs-type">Ast</span> <span class="hljs-type">Ast</span> 	| <span class="hljs-type">Var</span> <span class="hljs-type">String</span>

<span class="hljs-class"><span class="hljs-keyword">data</span> val = <span class="hljs-type">Numb</span> <span class="hljs-type">Integer</span> | <span class="hljs-type">Closure</span> <span class="hljs-type">String</span> <span class="hljs-type">Ast</span> <span class="hljs-type">Env</span></span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Env</span> = [(<span class="hljs-title">string</span>, <span class="hljs-title">val</span>)</span>

<span class="hljs-title">interp</span>::<span class="hljs-type">Ast</span> -&gt; <span class="hljs-type">Env</span> -&gt; <span class="hljs-type">Val</span>
<span class="hljs-title">interp</span> (<span class="hljs-type">Number</span> v)_ = <span class="hljs-type">Nub</span> v
<span class="hljs-title">interp</span> (<span class="hljs-type">Fun</span> p b) e = <span class="hljs-type">Closure</span> p b e
<span class="hljs-title">interp</span> (<span class="hljs-type">Bin</span> op x y) e = <span class="hljs-type">Numb</span> opTrans op v w
	<span class="hljs-keyword">where</span> 
		<span class="hljs-type">Numb</span> v = interp v e
		<span class="hljs-type">Numb</span> w = interp y e

<span class="hljs-title">interp</span> (<span class="hljs-type">App</span> f x) e = interp fb ((fb, y) : fe)
	<span class="hljs-keyword">where</span>
		<span class="hljs-type">Closure</span> fp fb fe = interp f e
		y = interp x e

<span class="hljs-comment">-- lookup x e returns a Maybe val</span>
<span class="hljs-comment">-- data Maybe a = </span>
<span class="hljs-comment">--     		Nothing | Just a</span>
<span class="hljs-comment">-- Undefined :: a</span>
<span class="hljs-title">interp</span> (var x e) = fromMaybe undefined (lookup x e)
</div></code></pre>
<p>Now let's add set (for mutation) and seq (for begin sequencing)</p>
<pre><code><div>exp = ... (stuff from before)
	| (set id exp)
	| (seq exp exp)
data Ast = ... |Set String Ast| Seq Ast Ast
data Val = ... | Void
</div></code></pre>
<ul>
<li>Note: We need to implement notation without actually using mutation - haskell doesn't have mutation</li>
<li>Implementing set: change the name-value binding in the env</li>
<li>Consider:</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name">with</span> ((<span class="hljs-name">x</span> <span class="hljs-number">0</span>))
	(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-name">seq</span> (<span class="hljs-name">set</span> x <span class="hljs-number">5</span>) x)
		(<span class="hljs-name">seq</span> (<span class="hljs-name">set</span> x <span class="hljs-number">6</span>) x)))
</div></code></pre>
<ul>
<li>This should output 11. How?
<ul>
<li>(set x 5) - changes the env so that x maps to 5. ie: create a new environment</li>
<li>Each step should return the env that results after it is finished, so that the updated env can be used in what follows</li>
<li>What about:</li>
</ul>
</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name">with</span> ((<span class="hljs-name">x</span> <span class="hljs-number">0</span>))
	(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-name">seq</span> (<span class="hljs-name">set</span> x <span class="hljs-number">5</span>) x)
		(<span class="hljs-name">seq</span> (<span class="hljs-name">with</span> ((<span class="hljs-name">x</span> <span class="hljs-number">10</span>)) <span class="hljs-number">0</span>) x)))
</div></code></pre>
<ul>
<li>
<p>Careful about returning envs: we want 10 not 15.</p>
</li>
<li>
<p>Can this model work? yes but requires care</p>
</li>
<li>
<p>How do you accommodate boxes? Need a model that permits aliasing</p>
</li>
<li>
<p><em>Store</em> maps <em>locations</em> to values. Values are updated, locations are not.</p>
</li>
<li>
<p>Interp takes a store as an additional param, returns an updated store as a result</p>
</li>
</ul>
<pre><code class="language-haskell"><div><span class="hljs-title">exp</span> = ... (stuff from before)
	| (set id exp)
	| (seq exp exp)
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Ast</span> = ... |<span class="hljs-type">Set</span> <span class="hljs-type">String</span> <span class="hljs-type">Ast</span>| <span class="hljs-type">Seq</span> <span class="hljs-type">Ast</span> <span class="hljs-type">Ast</span></span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Val</span> = ... | <span class="hljs-type">Void</span></span>

<span class="hljs-title">interp</span>:: <span class="hljs-type">Ast</span> -&gt; <span class="hljs-type">Env</span> -&gt; <span class="hljs-type">Store</span> -&gt; (<span class="hljs-type">Val</span>, <span class="hljs-type">Store</span>)
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Loc</span> = <span class="hljs-type">Integer</span></span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Env</span> = [(<span class="hljs-type">String</span>, <span class="hljs-type">Loc</span>)]</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Store</span> = [(<span class="hljs-type">Loc</span>, <span class="hljs-type">Val</span>)]</span>

<span class="hljs-title">interp</span> (<span class="hljs-type">Number</span> v)_ s = (<span class="hljs-type">Numb</span> v, s)

<span class="hljs-title">interp</span> (<span class="hljs-type">Fun</span> p b) e s = (<span class="hljs-type">Closure</span> p b e, s)

<span class="hljs-title">interp</span> (<span class="hljs-type">Bin</span> op x y) e s = (<span class="hljs-type">Numb</span>(opTrans op v w), s'')
	<span class="hljs-keyword">where</span> 
		(<span class="hljs-type">Numb</span> v, s') = interp x e s
		(<span class="hljs-type">Numb</span> w, s'') = interp y e s

<span class="hljs-title">interp</span> (seq x y) e s = (v, s'')
	<span class="hljs-keyword">where</span> 
		(_ , s') = interp x e s
		(v , s'') = interp y e s'

<span class="hljs-title">interp</span> (var x) e s = (fromMaybe undefined (lookup loc s), s)
	<span class="hljs-keyword">where</span> loc = fromMaybe undefined (lookup x e);
<span class="hljs-comment">--- create a new body environment store</span>
<span class="hljs-title">interp</span> (<span class="hljs-type">App</span> f x) e s = interp fb fe ns
	<span class="hljs-keyword">where</span> 
		(<span class="hljs-type">Closure</span> fp fb fe, s') = interp f e s
		(y s'') = interp x e s
		nl = newloc s''
		ne = (fp, nl): fe   	<span class="hljs-comment">--- new environment and store entry</span>
		ns = (nl, y) : s''

<span class="hljs-title">interp</span> (set x y) e s = (<span class="hljs-type">Void</span>, ns)
	<span class="hljs-keyword">where</span>
		<span class="hljs-comment">--- just put the new def on the front -&gt; lookup looks for the first occurrence anyway</span>
		lx = fromMaybe undefined (lookup x e)
		(nv, s') = interp y e s
		ns = (lx , nv) : s'

<span class="hljs-comment">--- this works because we never remove locations from the store</span>
<span class="hljs-comment">--- impractical for long computations</span>
<span class="hljs-comment">--- better: reuse old locations ("Garbage Collection")</span>
<span class="hljs-title">newloc</span> = length
</div></code></pre>
<h1 id="module-2-simp">Module 2: SIMP</h1>
<p><strong>Let's build our own imperative language: SIMP!</strong></p>
<ul>
<li>Statements</li>
<li>Sequencing</li>
<li>Conditional Execution (if)</li>
<li>Repetition (Loops)</li>
</ul>
<p>A SIMP program is a sequence of variable declarations, initialized to integers, followed by statements.</p>
<p>eg:</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">vars</span> [(<span class="hljs-name">x</span> <span class="hljs-number">0</span>) (<span class="hljs-name">y</span> <span class="hljs-number">1</span>) (<span class="hljs-name">z</span> <span class="hljs-number">2</span>)]
	(<span class="hljs-name">print</span> y))

_Grammar_: Program = `(vars [(id number) ... ] stmt ...)`
	
    stmt    = (<span class="hljs-name">print</span> aexp)
            | (<span class="hljs-name">print</span> string)
            | (<span class="hljs-name">set</span> id exp)
            | (<span class="hljs-name">seq</span> stmt ...)
            | (<span class="hljs-name">iif</span> bexp stmt stmt)
            | (<span class="hljs-name">skip</span>) 	    <span class="hljs-comment">;; does nothing</span>
            | (<span class="hljs-name">while</span> bexp stmt ...)
    aexp    = (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> | * | - | div | mod    aexp aexp)
            | number
            | id
    bexp    = (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> | &gt; | &lt; | &gt;= | &lt;=      aexp aexp)
            | (<span class="hljs-name"><span class="hljs-builtin-name">not</span></span> bexp)
            | (<span class="hljs-name"><span class="hljs-builtin-name">and</span></span> | or     bexp ...)
            | true | false
</div></code></pre>
<h2 id="racket-macros">Racket Macros</h2>
<ul>
<li>Transform one statement into a sequence of other ones</li>
<li>Turn a simp program into a racket program</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name">define-syntax-rule</span> 
	(<span class="hljs-name">vars</span> [(<span class="hljs-name">id</span> init) ... ] exp ...)
	(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [(<span class="hljs-name">id</span> init) ...] exp ...))
(<span class="hljs-name">define-syntax-rule</span> 
	(<span class="hljs-name">iif</span> test texp fexp)
	(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> test texp fexp))
(<span class="hljs-name">define-syntax-rule</span> 
	(<span class="hljs-name">while</span> test exp ...)
	(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> loop()
		(<span class="hljs-name"><span class="hljs-builtin-name">when</span></span> test
			exp ... (<span class="hljs-name">loop</span>))))

<span class="hljs-comment">; this is called named let -&gt; declare loop to be a function, then call it. (recursive)</span>
<span class="hljs-comment">; The rest are renames of existing racket functions.</span>

(<span class="hljs-name"><span class="hljs-builtin-name">provide</span></span> vars iif while
	(<span class="hljs-name">rename-out</span> [<span class="hljs-name"><span class="hljs-builtin-name">display</span></span> print] [<span class="hljs-name"><span class="hljs-builtin-name">begin</span></span> seq] [<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> set] [<span class="hljs-name">void</span> skip] [<span class="hljs-name"><span class="hljs-builtin-name">quotient</span></span> div] [<span class="hljs-name"><span class="hljs-builtin-name">modulo</span></span> mod])
	&gt; &gt;= &lt; &lt;= and or not + - * true false
	#%module-begin #%datum #%app #%top #%top-interaction)
</div></code></pre>
<p><strong>Example:</strong> compute all perfect numbers up to 10000. A perfect number is equal to the sum of it's divisors (except itself)</p>
<p>In SIMP:</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">vars</span> [(<span class="hljs-name">i</span> <span class="hljs-number">1</span>) (<span class="hljs-name">j</span> <span class="hljs-number">0</span>) (<span class="hljs-name">acc</span> <span class="hljs-number">0</span>)]
	(<span class="hljs-name">while</span> (<span class="hljs-name"><span class="hljs-builtin-name">&lt;=</span></span> i <span class="hljs-number">10000</span>)
		(<span class="hljs-name">set</span> j <span class="hljs-number">1</span>)
		(<span class="hljs-name">set</span> acc <span class="hljs-number">0</span>)
		(<span class="hljs-name">while</span> (<span class="hljs-name"><span class="hljs-builtin-name">&lt;</span></span> j i)
			(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> (<span class="hljs-name">mod</span> i j) <span class="hljs-number">0</span>) 
				(<span class="hljs-name">set</span> acc (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> acc j))
				(<span class="hljs-name">skip</span>))
			(<span class="hljs-name">set</span> j (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> j <span class="hljs-number">1</span>)))
		(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> acc i)
			(<span class="hljs-name">seq</span> (<span class="hljs-name">print</span> i) (<span class="hljs-name">print</span> <span class="hljs-string">"\n"</span>))
			(<span class="hljs-name">skip</span>))
		(<span class="hljs-name">set</span> i (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">1</span> i))))
</div></code></pre>
<p>In C:</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10000</span>; i++){
		<span class="hljs-keyword">int</span> acc = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++){
			<span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>) acc += j;
		}
		<span class="hljs-keyword">if</span> (acc == i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i);
	}
}
</div></code></pre>
<h2 id="semantics-1">Semantics</h2>
<ul>
<li>map from states to states
<ul>
<li>A state <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span> provides values of vars (ignoring output)
<ul>
<li>map from variable to integer values</li>
<li>Does not have boxes so will not separate to environment and store</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Notation</strong>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>x</mi><mo>↦</mo><mi>i</mi><mo>]</mo><mi>σ</mi></mrow><annotation encoding="application/x-tex">[x \mapsto i] \sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span> is the state that maps <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> and any other <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mo>(</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></p>
<p>Rewrite rules for pairs <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>π</mi><mo separator="true">,</mo><mi>σ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(\pi, \sigma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mclose">)</span></span></span></span> (program, state)
(Omitting rules that remain unchanged)</p>
<pre><code class="language-scheme"><div>((<span class="hljs-name">set</span> x, n) \sigma) =&gt; (,[<span class="hljs-name">x-&gt;n</span>]\sigma)
(<span class="hljs-name">iif</span> true s1 s2), \sigma) =&gt; (<span class="hljs-name">s1</span>, \sigma)
(<span class="hljs-name">iif</span> false s1 s2), \sigma) =&gt; (<span class="hljs-name">s2</span>, \sigma)
((<span class="hljs-name">while</span> t s1 ... si), \sigma) =&gt; ((<span class="hljs-name">iif</span> t (<span class="hljs-name">seq</span> s1 ... si (<span class="hljs-name">while</span> t s1 ... si)) (<span class="hljs-name">skip</span>)), \sigma) 
</div></code></pre>
<ul>
<li>Initial pair <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>π</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>σ</mi><mn>0</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(\pi_0, \sigma_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>
<ul>
<li>If the program is <code>(vars [(x1 n1) ... (xi ni)] s1 ... si)</code></li>
</ul>
</li>
<li>Then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = <code>(seq s1 ... si)</code> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\sigma_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is the function such that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>⋯</mo><mi>i</mi><mo separator="true">,</mo><mi>σ</mi><mo>(</mo><msub><mi>x</mi><mi>k</mi></msub><mo>)</mo><mo>=</mo><msub><mi>n</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">k = 1\cdots i, \sigma(x_k) = n_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
<h2 id="interpreter-haskell">Interpreter: Haskell</h2>
<pre><code class="language-haskell"><div><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Aop</span> = <span class="hljs-type">Plus</span> | <span class="hljs-type">Minus</span> | <span class="hljs-type">Times</span> | <span class="hljs-type">Mod</span> | <span class="hljs-type">Div</span></span>

<span class="hljs-title">opTrans</span> <span class="hljs-type">Plus</span> = (+)
<span class="hljs-title">opTrans</span> <span class="hljs-type">Minus</span> = (-)
... etc

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Aexp</span> = <span class="hljs-type">Number</span> <span class="hljs-type">Integer</span> | <span class="hljs-type">Var</span> <span class="hljs-type">String</span> | <span class="hljs-type">Abin</span> <span class="hljs-type">Aop</span> <span class="hljs-type">Aexp</span> <span class="hljs-type">Aexp</span></span>

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Bop</span> = <span class="hljs-type">Lt</span> | <span class="hljs-type">Gt</span> | <span class="hljs-type">Le</span> | <span class="hljs-type">Ge</span> | <span class="hljs-type">Eq</span></span>

<span class="hljs-title">bopTrans</span> <span class="hljs-type">Lt</span> = (&lt;)
<span class="hljs-title">bopTrans</span> <span class="hljs-type">Gt</span> = (&gt;)
... etc

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Bexp</span> 	= <span class="hljs-type">BBin</span> <span class="hljs-type">Bop</span> <span class="hljs-type">Aexp</span> <span class="hljs-type">Aexp</span></span>
			| <span class="hljs-type">Not</span> <span class="hljs-type">Bexp</span>.
			| <span class="hljs-type">And</span> <span class="hljs-type">Bexp</span> <span class="hljs-type">Bexp</span>
			| <span class="hljs-type">Or</span> <span class="hljs-type">Bexp</span> <span class="hljs-type">Bexp</span>
			| <span class="hljs-type">Bval</span> <span class="hljs-type">Bool</span>

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Stmt</span> = <span class="hljs-type">Skip</span> | <span class="hljs-type">Set</span> <span class="hljs-type">String</span> <span class="hljs-type">Aexp</span> | <span class="hljs-type">Iif</span> <span class="hljs-type">Bexp</span> <span class="hljs-type">Stmt</span> <span class="hljs-type">Stmt</span> | <span class="hljs-type">Seq</span> <span class="hljs-type">Stmt</span> <span class="hljs-type">Stmt</span> | <span class="hljs-type">While</span> <span class="hljs-type">Bexp</span> <span class="hljs-type">Stmt</span></span>
<span class="hljs-comment">-- note print is left out</span>
 
<span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.Map <span class="hljs-keyword">as</span> m

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">State</span> = <span class="hljs-type">M</span>.<span class="hljs-type">Map</span> <span class="hljs-type">String</span> <span class="hljs-type">Integer</span></span>

<span class="hljs-title">aeval</span>::<span class="hljs-type">Aexp</span> -&gt; <span class="hljs-type">State</span> -&gt; <span class="hljs-type">Integer</span>
<span class="hljs-title">aeval</span> (<span class="hljs-type">Number</span> n)_ = n
<span class="hljs-title">aeval</span> (<span class="hljs-type">Var</span> x)s = <span class="hljs-type">M</span>.findWithDefault undefined x s
<span class="hljs-title">aeval</span> (<span class="hljs-type">Abin</span> aop ae1 ae2) s = aopTrans aop (aeval ae1 s) (aeval ae2 s)

<span class="hljs-title">beval</span>:: <span class="hljs-type">Bexp</span> -&gt; <span class="hljs-type">State</span> -&gt; <span class="hljs-type">Bool</span>
<span class="hljs-title">beval</span> (<span class="hljs-type">Bval</span> b)_ = b
<span class="hljs-title">beval</span> (<span class="hljs-type">Not</span> be) st = not (<span class="hljs-type">Beval</span> be st)
<span class="hljs-title">beval</span> (<span class="hljs-type">And</span> be1 be2) st = (beval be1 st) &amp;&amp; (beval be2 st)
<span class="hljs-title">beval</span> (<span class="hljs-type">Or</span> be1 be2) st = (beval be1 st) || (beval be2 st)
<span class="hljs-title">beval</span> (<span class="hljs-type">BBin</span> bop ae1 ae2) st = bopTrans bop (aeval ae1 st) (aeval ae2 st)

<span class="hljs-title">interp</span>:: <span class="hljs-type">Stmt</span> -&gt; <span class="hljs-type">State</span> -&gt; <span class="hljs-type">State</span>

<span class="hljs-title">interp</span> <span class="hljs-type">Skip</span> st = st
<span class="hljs-title">interp</span> (<span class="hljs-type">Set</span> x ae) = <span class="hljs-type">Map</span>.insert x $!(aeval ae st) st <span class="hljs-comment">--- $! forces evaluation of ae</span>
<span class="hljs-title">interp</span> (<span class="hljs-type">Iif</span> be ts fs) = <span class="hljs-keyword">if</span> (beval be st) <span class="hljs-keyword">then</span> (interp ts st) <span class="hljs-keyword">else</span> (interp fs st)
<span class="hljs-title">interp</span> (<span class="hljs-type">Seq</span> s1 s2) st = <span class="hljs-keyword">let</span> st' = interp s1 st <span class="hljs-keyword">in</span> interp s2 st'
<span class="hljs-title">interp</span> loop@(<span class="hljs-type">While</span> bt body) st = interp (<span class="hljs-type">Iif</span> bt (<span class="hljs-type">Seq</span> body <span class="hljs-type">Loop</span>) <span class="hljs-type">Skip</span>) st
</div></code></pre>
<h3 id="adding-printing">Adding Printing:</h3>
<p>Recall from module 1,</p>
<ul>
<li>Can model output as a list of chars that would be printed. (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span> part of the state)</li>
</ul>
<pre><code class="language-haskell"><div><span class="hljs-title">interp</span>:: <span class="hljs-type">Stmt</span> -&gt; <span class="hljs-type">State</span> -&gt; <span class="hljs-type">String</span> -&gt; (<span class="hljs-type">State</span>,<span class="hljs-type">String</span>)
</div></code></pre>
<p>Adding print statements to the Ast:</p>
<pre><code class="language-haskell"><div><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Stmt</span> 	= ...</span>
			| <span class="hljs-type">IPrint</span> <span class="hljs-type">Aexp</span>
			| <span class="hljs-type">SPrint</span> <span class="hljs-type">String</span>

<span class="hljs-title">interp</span> <span class="hljs-type">Skip</span> st om = (st, om)
<span class="hljs-title">interp</span> (<span class="hljs-type">Set</span> x ae) st om = (<span class="hljs-type">M</span>.insert x $!(aeval ae st) st, om)
<span class="hljs-title">interp</span> (<span class="hljs-type">Iif</span> be ts fs) st om = <span class="hljs-keyword">if</span> (beval ae st) <span class="hljs-keyword">then</span> interp ts st om <span class="hljs-keyword">else</span> interp fs st om
<span class="hljs-title">interp</span> loop @(<span class="hljs-type">While</span> bt body) st om = interp (<span class="hljs-type">Iif</span> bt (seq body loop) <span class="hljs-type">Skip</span>) st om

<span class="hljs-comment">--- Sequencing</span>
<span class="hljs-title">interp</span> (<span class="hljs-type">Seq</span> s1 s2) st om = <span class="hljs-keyword">let</span> (st', om') = interp s1 st om
							<span class="hljs-keyword">in</span> interp s2 st' om'
<span class="hljs-title">interp</span> (<span class="hljs-type">IPrint</span> ae) st om = (st om ++ (show (aeval ae st)))
<span class="hljs-title">interp</span> (<span class="hljs-type">SPrint</span> s) st om = (st, om ++ s)

<span class="hljs-comment">--- Print: You give me a program and a state, ill give you the string transform (whatever you need to do to get the new output state)</span>
</div></code></pre>
<ul>
<li><code>interp :: Stmt -&gt; State -&gt; String -&gt; (State, String)</code></li>
<li>String Transformer: Stirng -&gt; (State, String)</li>
<li>Factor this out of the type</li>
</ul>
<pre><code class="language-haskell"><div><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Mio</span> a = <span class="hljs-type">String</span> -&gt; (<span class="hljs-title">a</span>, <span class="hljs-type">String</span>) <span class="hljs-comment">--- string transformer</span></span>

<span class="hljs-title">interp</span>:: <span class="hljs-type">Stmt</span> -&gt; <span class="hljs-type">State</span> -&gt; <span class="hljs-type">Mio</span> <span class="hljs-type">State</span>

<span class="hljs-comment">--- Helper FUnctions:</span>
<span class="hljs-title">inject</span> :: a -&gt; <span class="hljs-type">Mio</span> a
<span class="hljs-title">inject</span> x = \om -&gt; (x, om)

<span class="hljs-title">miprint</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Mio</span> ()

<span class="hljs-title">miprint</span> s = \ om -&gt; ((), om++s)

<span class="hljs-comment">--- Abstract the behaviour to seq</span>

<span class="hljs-title">interp</span> (<span class="hljs-type">Seq</span> s1 s2) st om = 
	<span class="hljs-keyword">let</span> (st` om`) = interp s1 st om <span class="hljs-keyword">in</span> interp s2 st` om`

	<span class="hljs-comment">--- This doesn't work -&gt; st`</span>
	= (<span class="hljs-keyword">if</span>-&gt;<span class="hljs-keyword">let</span> (st` om`) = f om <span class="hljs-keyword">in</span> interp s2 st` om`) (interp s1 st)
	<span class="hljs-comment">--- this works:</span>
	= (<span class="hljs-keyword">if</span>-&gt;<span class="hljs-keyword">let</span> (st`, om`) = f om <span class="hljs-keyword">in</span> (\x -&gt; interp s2 x) st` om`)(interp s1 st)

<span class="hljs-comment">--- New operator "bind"</span>
(&gt;&gt;&gt;=) :: <span class="hljs-type">Mio</span> a -&gt; (a -&gt; <span class="hljs-type">Mio</span> b) -&gt; <span class="hljs-type">Mio</span> b
<span class="hljs-title">m</span>&gt;&gt;&gt;=g = lom -&gt; <span class="hljs-keyword">let</span> (av, om')=(m om <span class="hljs-keyword">in</span> g av om`)

<span class="hljs-comment">---Simplification: for when g doesn't need the value av.</span>
(&gt;&gt;&gt;):: <span class="hljs-type">Mio</span> a -&gt; <span class="hljs-type">Mio</span> b -&gt; <span class="hljs-type">Mio</span> b
<span class="hljs-title">f</span>&gt;&gt;&gt;k = f &gt;&gt;&gt;= \_ -&gt; k
</div></code></pre>
<p>Actually apply:</p>
<pre><code class="language-haskell"><div><span class="hljs-title">interp</span>:: <span class="hljs-type">Stmt</span> -&gt; <span class="hljs-type">State</span> -&gt; <span class="hljs-type">Mio</span> <span class="hljs-type">State</span>
<span class="hljs-title">interp</span> skip st = inject st
<span class="hljs-title">interp</span> (<span class="hljs-type">Set</span> x ne) st = inject(<span class="hljs-type">M</span>.insert x $<span class="hljs-number">1</span> (aeval ae st) st)
<span class="hljs-title">interp</span> (<span class="hljs-type">If</span> be ts fs) st = <span class="hljs-keyword">if</span> (beval be st) <span class="hljs-keyword">then</span> interp ts st <span class="hljs-keyword">else</span> interp fs st
<span class="hljs-title">interp</span> (<span class="hljs-type">Seq</span> s1 s2) st = interp s1 st &gt;&gt;&gt;= \st` -&gt; interp s2 st`
<span class="hljs-title">interp</span> loop@(while bt body) st = interp (<span class="hljs-type">Iif</span> bt (seq body loop) <span class="hljs-type">Skip</span>) st
<span class="hljs-title">interp</span> (<span class="hljs-type">IPrint</span> ae) st = miprint (<span class="hljs-type">Show</span> (aeval ae st)) &gt;&gt;&gt; inject st
<span class="hljs-title">interp</span> (<span class="hljs-type">SPrint</span> s) st = miprint s &gt;&gt;&gt; inject st
</div></code></pre>
<p>Native Haskell Approach:</p>
<pre><code class="language-haskell"><div><span class="hljs-type">Mio</span> a -&gt; <span class="hljs-type">IO</span> a
<span class="hljs-title">miprint</span> -&gt; putstr
&gt;&gt;&gt;= -&gt; &gt;&gt;=
&gt;&gt;&gt; -&gt; &gt;&gt;
<span class="hljs-title">inject</span> -&gt; return
</div></code></pre>
<p>Haskell print is real hard.</p>
<pre><code class="language-haskell"><div><span class="hljs-title">e1</span> &gt;&gt; e2 <span class="hljs-comment">---&gt; do eq; e2</span>
<span class="hljs-title">e1</span> &gt;&gt;= e2 <span class="hljs-comment">---&gt; do p&lt;-e1 ; e2</span>

<span class="hljs-comment">--- eg:</span>

<span class="hljs-title">interp</span> (<span class="hljs-type">Seq</span> s1 s2) st = <span class="hljs-keyword">do</span> st` &lt;- interp s1 st; interp s2 st`
<span class="hljs-title">interp</span> (<span class="hljs-type">IPrint</span> ae) st = <span class="hljs-keyword">do</span> putStr(show (aeval ae st); return st)
<span class="hljs-title">interp</span> (<span class="hljs-type">SPrint</span> s) st = <span class="hljs-keyword">do</span> putStr s; return s;
</div></code></pre>
<p>IO is an example of a <strong>monad</strong>
- any data type with &gt;&gt;= and return operators
- Monads help to model otherwise impure effects purely
- abstract away the plumbing that ensures effects are properly sequenced</p>
<h1 id="proofs-in-imperative-programs">Proofs in imperative Programs</h1>
<p>Exercise: Write an accumulatively recursive fib, find an invariant, rpove correct.
What would thatl ook like in SIMP?  Set n initially mutable (no functions)</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">vars</span> [(<span class="hljs-name">n</span> <span class="hljs-number">10</span>) (<span class="hljs-name">fj</span> <span class="hljs-number">1</span>) (<span class="hljs-name">fjm1</span> <span class="hljs-number">0</span>) (<span class="hljs-name">ans</span> <span class="hljs-number">0</span>)]
	(<span class="hljs-name">iif</span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> n <span class="hljs-number">0</span>)
		(<span class="hljs-name">set</span> ans (<span class="hljs-name">fjm1</span>))
		(<span class="hljs-name">seq</span> (<span class="hljs-name">while</span> (<span class="hljs-name"><span class="hljs-builtin-name">&gt;</span></span> n <span class="hljs-number">1</span>)
				(<span class="hljs-name">set</span> (<span class="hljs-name">fjm1</span> fj))
				(<span class="hljs-name">set</span> (<span class="hljs-name">fj</span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> fj fjm1))
				(<span class="hljs-name">set</span> n (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">1</span>)))
			(<span class="hljs-name">set</span> ans fj))))
	(<span class="hljs-name">print</span> ans))
</div></code></pre>
<p>Wrong, fjm1 is updated prematurely
Swap (set fj (+ fj fjm1)) with (set fjm1 fj)?</p>
<ul>
<li>Still wrong. Fj updated prematurely.</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name">vars</span> [(<span class="hljs-name">n</span> <span class="hljs-number">10</span>) (<span class="hljs-name">fj</span> <span class="hljs-number">1</span>) (<span class="hljs-name">fjm1</span> <span class="hljs-number">0</span>) (<span class="hljs-name">ans</span> <span class="hljs-number">0</span>)]
	(<span class="hljs-name">iif</span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> n <span class="hljs-number">0</span>)
		(<span class="hljs-name">set</span> ans (<span class="hljs-name">fjm1</span>))
		(<span class="hljs-name">seq</span> (<span class="hljs-name">while</span> (<span class="hljs-name"><span class="hljs-builtin-name">&gt;</span></span> n <span class="hljs-number">1</span>)
				(<span class="hljs-name">set</span> t fj)
				(<span class="hljs-name">set</span> fj (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> fj fjm1))
				(<span class="hljs-name">set</span> (<span class="hljs-name">fjm1</span> t))
				(<span class="hljs-name">set</span> n (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">1</span>)))
			(<span class="hljs-name">set</span> ans fj))))
	(<span class="hljs-name">print</span> ans))
</div></code></pre>
<h2 id="hoare-logic">Hoare Logic</h2>
<p>Prove triples of the form {P} statement {Q} -&gt; Hoare triples</p>
<pre><code>P - precondition: Typical statement about the state before the stmt runs
Q - Postcondition - logical stmt about the state after the stmt runs
</code></pre>
<p>Interpretation: &quot;If P is true before statement runs, then Q is true after statement runs&quot;</p>
<p>EX: To conclude <code>{P} (vars P[(x1 v1) ... (xn vn)] stmt ... ) {Q}</code></p>
<p>It suffices to show how <code>{P and x1 = v1 and ... and xn = vn}(seq stmt ...) {Q}</code></p>
<p>To conclude <code>{P} (seq stmt1 stmt2) {Q}</code>, it suffices to find a statement R such that <code>{P} stmt1 {R}</code>, <code>{R} stmt2 {Q}</code></p>
<p>Finding R can be tricky - May need to adjust P and Q to get an R that works. What freedom do we have? To conclude {P'} stmt {Q'}, we can prove {P} stmt {Q}, where P' <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> P and Q <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> Q'</p>
<p>(P' <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> P stmt Q <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> Q') <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> (P' stmt Q')</p>
<p>To conclude <code>{P}(set x exp){Q},</code></p>
<ul>
<li>P + Q should be almost the same - only the value of x has changed</li>
<li>Q can say nothing about the old value of x</li>
<li>Whatever Q says about x must be true for exp before the statement
<ul>
<li>so <code>{Q[exp/x]} (setx exp) {Q}</code></li>
<li><code>Q[exp/x]</code> means Q with the expression substituted in place of x</li>
</ul>
</li>
</ul>
<p>To conclude {P}(iif B stmt1 stmt2){Q}</p>
<ul>
<li>Suffices to show: {P and B} stmt1 {Q}, {P and not B} stmt2 {Q}</li>
</ul>
<p>(while B stmt...) - trickiest</p>
<p>If the loop does not run,  <code>{P}(while B stmt...){P}</code>, and B must be false.</p>
<p><code>{P}(while B stmt...){P and not B}</code></p>
<p>If the loop repeats, the last thing the loop does is check the condition. Whatever is true at the end of the loop is true at the next beginning of the loop, and B is true: <code>{P and B}(seq s1 ... sn) {P}</code> . P is preserved by the body of the loop - called a <strong>Loop Invariant</strong>. Finding the right loop invariant can be very tricky</p>
<p><strong>Prove that Fib (simplified) works</strong></p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">vars</span> [(<span class="hljs-name">n</span> <span class="hljs-number">10</span>) (<span class="hljs-name">fj</span> <span class="hljs-number">1</span>) (<span class="hljs-name">fjm1</span> <span class="hljs-number">0</span>) (<span class="hljs-name">ans</span> <span class="hljs-number">0</span>) (<span class="hljs-name">t</span> <span class="hljs-number">0</span>)]
	<span class="hljs-comment">; Start: n = 10, fj = F(1), fjm1 = F(0), t=0</span>
	<span class="hljs-comment">; {P} = {f = F(11-n), fjm1 = F(10 - n)}</span>
	(<span class="hljs-name">while</span> (<span class="hljs-name"><span class="hljs-builtin-name">not</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> n <span class="hljs-number">1</span>))
		<span class="hljs-comment">; fj + fjm1 = F(12 - n), fj = F(11-n) =&gt; fj + fjm1 = F(11-n) + F(10-n) = F(12-n)</span>
		(<span class="hljs-name">set</span> t fj)
		<span class="hljs-comment">; fj + fjm1 = F(12 - n), t = F(11-n)</span>
		(<span class="hljs-name">set</span> fj (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> fj fjm1))
		<span class="hljs-comment">; f = F(12 - n), t = F(11 - n)</span>
		(<span class="hljs-name">set</span> fjm1 t)
		<span class="hljs-comment">; f = F(12 - n), fjm1 = F(11 - n)</span>
		(<span class="hljs-name">set</span> n (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">1</span>))))

		<span class="hljs-comment">; f = F(11- n), fjm1 = F(10 - n), n = 1 (implies goal).</span>
		<span class="hljs-comment">; goal: fj = F(10)</span>
</div></code></pre>
<p>How do you pick invariants? By the end of the loop, your condition should still hold. Work bottom up - pushing changes upwards.</p>
<h1 id="module-3-primp-primitive-imperative-language">Module 3: PRIMP (Primitive Imperative Language)</h1>
<p>SIMP is still to complicated. So far, the abstracted syntax of the language is stored in s-expressions (tree structured data). Trees are an abstraction - basic machine has only memory, not trees. Let us now store our pgram as a <em>vector</em>.</p>
<p>A Program is now a sequence of instructions. The RAM used for data will be the same RAM that holds the program. Reasoning about the program - no longer about rewriting. The program remains fixed. We need to keep track of where we are in the program.</p>
<p>Index in to the program, called the <strong>Program Counter (PC)</strong> holds the location of the next instruction to be executed. The <strong>Simulator</strong> runs a fetch-executable cycle.</p>
<ul>
<li>Fetch instruction at given location</li>
<li>Execute the fetched instruction</li>
<li>For clarity, assume PC is a separate variable, outside the RAM that holds the program.</li>
</ul>
<p>To further get rid of lies, <em>NO named variables</em>_, only locations in RAM. Variables will be referenced by locaiton, starting right after the program. However, unbounded integers will be allowed (fixed later)</p>
<p>SIMP allows arbitrarily complex expressions.</p>
<p>Primp - only one operation at a time. Constant space instructions.</p>
<p>AN arithmetic statement has 3 arguments - 2 operands + a destination. Operands wnat to allow both numbers &quot;2&quot; and locations &quot;(2)&quot;, where &quot;2&quot; is the number 2, and &quot;(2)&quot; is the value at the location 2.</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">add</span> (<span class="hljs-name">5</span>) (<span class="hljs-name">1</span>) (<span class="hljs-name">2</span>)) == M[<span class="hljs-name">5</span>] &lt;- M[<span class="hljs-name">1</span>] + M[<span class="hljs-name">2</span>] 
(<span class="hljs-name">add</span> (<span class="hljs-name">7</span>) (<span class="hljs-name">7</span>) (<span class="hljs-name">1</span>)) == M[<span class="hljs-name">7</span>] &lt;= M[<span class="hljs-name">7</span>] + <span class="hljs-number">1</span>
</div></code></pre>
<p>Operations: <code>add sub mul div mod equal not-equal gt ge lt le land lor lnot</code></p>
<p><strong>Loops and ifs:</strong> Programs are no longer tree structured, so how will you know where to go? Replace them with unconditial jump and conditional branch</p>
<p>(jump 12) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span></span></span></span> PC <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">←</span></span></span></span> 12</p>
<p>(branch (20) 12) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span></span></span></span> if M[20] then PC <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">←</span></span></span></span> 21</p>
<p><strong>Print</strong></p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">print-val</span> <span class="hljs-number">21</span>)      <span class="hljs-comment">; prints 21</span>
(<span class="hljs-name">print-val</span> (<span class="hljs-name">15</span>))    <span class="hljs-comment">; prints M[15]</span>
(<span class="hljs-name">print-string</span> <span class="hljs-string">"\n"</span>) <span class="hljs-comment">; prints "\n"</span>
</div></code></pre>
<p>eg:</p>
<pre><code class="language-scheme"><div><span class="hljs-comment">; in SIMP:</span>
(<span class="hljs-name">vars</span> [(<span class="hljs-name">x</span> <span class="hljs-number">10</span>) (<span class="hljs-name">y</span> <span class="hljs-number">1</span>)]
    (<span class="hljs-name">while</span> (<span class="hljs-name"><span class="hljs-builtin-name">&gt;</span></span> x <span class="hljs-number">0</span>)
        (<span class="hljs-name">set</span> y (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> <span class="hljs-number">2</span> y))
        (<span class="hljs-name">set</span> x (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> x <span class="hljs-number">1</span>))
        (<span class="hljs-name">print</span> y)
        (<span class="hljs-name">print</span> <span class="hljs-string">"\n"</span>)))

<span class="hljs-comment">; In PRIMP:</span>
(<span class="hljs-name">gt</span> (<span class="hljs-name">11</span>) (<span class="hljs-name">9</span>) <span class="hljs-number">0</span>)     <span class="hljs-comment">; 0: tmp1 &lt;- x &gt; 0</span>
(<span class="hljs-name">branch</span> (<span class="hljs-name">11</span>) <span class="hljs-number">3</span>)     <span class="hljs-comment">; 1: if tmp1 goto 3</span>
(<span class="hljs-name">jump</span> <span class="hljs-number">8</span>)            <span class="hljs-comment">; 2: goto 8</span>
(<span class="hljs-name">mul</span> (<span class="hljs-name">10</span>) <span class="hljs-number">2</span> (<span class="hljs-name">10</span>))   <span class="hljs-comment">; 3: y &lt;- 2 * y</span>
(<span class="hljs-name">sub</span> (<span class="hljs-name">4</span>) (<span class="hljs-name">4</span>) <span class="hljs-number">1</span>)     <span class="hljs-comment">; 4: x &lt;- x - 1</span>
(<span class="hljs-name">print-val</span> (<span class="hljs-name">10</span>))    <span class="hljs-comment">; 5: print y</span>
(<span class="hljs-name">print-string</span> <span class="hljs-string">"\n"</span>) <span class="hljs-comment">; 6: print "\n"</span>
(<span class="hljs-name">jump</span> <span class="hljs-number">0</span>)            <span class="hljs-comment">; 7: goto 0</span>
<span class="hljs-number">0</span>                   <span class="hljs-comment">; 8: 0</span>
<span class="hljs-number">10</span>                  <span class="hljs-comment">; 9: x</span>
<span class="hljs-number">1</span>                   <span class="hljs-comment">; 10: y</span>
<span class="hljs-number">0</span>                   <span class="hljs-comment">; 11: tmp1 - execute a 0, halts program</span>
</div></code></pre>
<h2 id="primp-simulator">Primp Simulator</h2>
<ul>
<li>So we can run primp programs</li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> mem (<span class="hljs-name"><span class="hljs-builtin-name">make-vector</span></span> MEMSIZE))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> pc <span class="hljs-number">0</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> halted? <span class="hljs-literal">#f</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">mem-get</span> i) (<span class="hljs-name"><span class="hljs-builtin-name">vector-ref</span></span> mem i))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">memset!</span> i newv) (<span class="hljs-name"><span class="hljs-builtin-name">vector-set!</span></span> mem i newv)

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">load-primp</span> prog-list)
    (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> halted <span class="hljs-literal">#f</span>)
    (<span class="hljs-name">vevctor-fill!</span> mem <span class="hljs-number">0</span>)
    (<span class="hljs-name">for</span> [(<span class="hljs-name">i</span> MEMSIZE)(<span class="hljs-name">c</span> (<span class="hljs-name">in-list</span> prog-list))]
        (<span class="hljs-name">mem-set!</span> i c)))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">run-primp</span>)
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> loop()
        (<span class="hljs-name"><span class="hljs-builtin-name">unless</span></span> halted?
            (<span class="hljs-name">fetch-execute-once</span>)
                (<span class="hljs-name">loop</span>))))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">fetch-executable-once</span>)
    (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> inst (<span class="hljs-name">mem-get</span> pc))
        (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> [(<span class="hljs-name"><span class="hljs-builtin-name">list?</span></span> inst) (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> pc (<span class="hljs-name">add1</span> pc))
                            (<span class="hljs-name">dispatch-inst</span> inst)]
              [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> halted <span class="hljs-literal">#t</span>)]))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">print-string</span> s) (<span class="hljs-name">printf</span> <span class="hljs-string">"~a"</span> s))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">print-val</span> op)
    (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> val (<span class="hljs-name">get-op-imm-or-mem</span> op))
    (<span class="hljs-name">printf</span> <span class="hljs-string">"~a"</span> val))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">get-op-imm-or-mem</span> op)
    (<span class="hljs-name">match</span> op
        [(<span class="hljs-name">?</span> number? v) v]
        [('(,i) (<span class="hljs-name">mem-get</span> i))]
        [<span class="hljs-name">x</span> (<span class="hljs-name">primp-error</span> <span class="hljs-string">"Bad operand: ~a\n"</span> op)]))

<span class="hljs-comment">; Similar: get-op-mem, set-dest!</span>

<span class="hljs-comment">; Arithmetic Operators:</span>
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> ((<span class="hljs-name">bin-num-op</span> op) dest src1 src2) <span class="hljs-comment">; curried function</span>
    (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> opnd1 (<span class="hljs-name">get-op-imm-or-mem</span> src1))
    (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> opnd2 (<span class="hljs-name">get-op-imm-or-mem</span> src2))
    (<span class="hljs-name">set-dest</span> dest (<span class="hljs-name">op</span> opnd1 opnd2)))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> add (<span class="hljs-name">bin-num-op</span> +))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> sub (<span class="hljs-name">bin-num-op</span> -))
...

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">move</span> dest src)
    (<span class="hljs-name">set-dest!</span> dest (<span class="hljs-name">op-get-imm-or-mem</span> src)))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">jump</span> val) (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> pc val))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">branch</span> opnd bc)
    (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> tested (<span class="hljs-name">get-op-mem</span> opnd))
    (<span class="hljs-name"><span class="hljs-builtin-name">when</span></span> tested (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> pc loc)))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> dispatch-table 
    (<span class="hljs-name">hash</span>   `print-val      print-val
            <span class="hljs-symbol">'print-string</span>   print-string
            `add            add
            `sub            sub
            ...))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">dispatch-inst</span> inst)
    (<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> (<span class="hljs-name">hash-ref</span> dispatch-table (<span class="hljs-name">first</span> inst))
        (<span class="hljs-name">rest</span> inst)))

<span class="hljs-comment">; Use:</span>
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">test-prog</span> `((gt (<span class="hljs-number">11</span>) (<span class="hljs-number">9</span>) <span class="hljs-number">0</span>) (branch (<span class="hljs-number">11</span>) <span class="hljs-number">3</span>) (jump <span class="hljs-number">8</span>) ...
                    <span class="hljs-number">0</span> <span class="hljs-number">10</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>)))

(<span class="hljs-name">load-primp</span> test-prog)
(<span class="hljs-name">run-primp</span>)
</div></code></pre>
<h2 id="a-primp">A-PRIMP</h2>
<p>How can we make PRIMP programming easier? Add nice features to PRIMP.</p>
<ul>
<li>Create a higher level language A-PRIMP</li>
<li>Create a translator from A-PRIMP to PRIMP</li>
</ul>
<p>A-PRIMP adds pseudoinstructions - shrothands for ordinary primp</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">lit</span> <span class="hljs-number">4</span>) <span class="hljs-comment">; "Literal"</span>
        <span class="hljs-comment">; "Insert  the value 4'</span>
        <span class="hljs-comment">; Just for readability</span>

(<span class="hljs-name">halt</span>)  <span class="hljs-comment">; Stop the program</span>
        <span class="hljs-comment">; just produces 0</span>

(<span class="hljs-name">const</span> NAME <span class="hljs-number">6</span>)  <span class="hljs-comment">; create a symbol NAME with value 6</span>
                <span class="hljs-comment">; does not generate an element in the PRIMP array</span>
                <span class="hljs-comment">; "replace all occurrences of NAME with 6"</span>
</div></code></pre>
<p><strong>Aside: C</strong></p>
<pre><code class="language-c"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE 100</span>
</div></code></pre>
<p>same thing as above. This is a preprocessor directive that replaces SIZE with 100 1. It's not the 70s don't do this lol. Just use const.</p>
<p><strong>(Back to A-PRIMP)</strong></p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">label</span> NAME)    <span class="hljs-comment">; no entry in the PRIMP array</span>
                <span class="hljs-comment">; symbol NAME is equal to the location in the vector where the next instruction would be placed</span>
                <span class="hljs-comment">; Used as a target for branch/jump</span>

(<span class="hljs-name">data</span> NAME (<span class="hljs-name">10</span> <span class="hljs-number">1</span>)) <span class="hljs-comment">; equivalent to (data NAME 1111111111)</span>

<span class="hljs-comment">; Name can be used as an indirect operand</span>

(<span class="hljs-name">add</span> NAME NAME <span class="hljs-number">1</span>) <span class="hljs-comment">; assuming name = 40</span>
= (<span class="hljs-name">add</span> (<span class="hljs-name">40</span>) (<span class="hljs-name">40</span>) <span class="hljs-number">1</span>)
</div></code></pre>
<p>Now rewrite power of 2 in A-Primp</p>
<pre><code class="language-lisp"><div>(<span class="hljs-name">label</span> LOOP-TOP)
(<span class="hljs-name">gt</span> TMP1 X <span class="hljs-number">0</span>)
(<span class="hljs-name">branch</span> TMP1 LOOP-COUNT)
(<span class="hljs-name">jump</span> LOOP-DONE)
(<span class="hljs-name">label</span> LOOP-COUNT)
****(<span class="hljs-name">mul</span> Y <span class="hljs-number">2</span> Y)
(<span class="hljs-name">sub</span> X X <span class="hljs-number">1</span>)
(<span class="hljs-name">print-val</span> Y)
(<span class="hljs-name">print-string</span> <span class="hljs-string">"\n"</span>)
(<span class="hljs-name">jump</span> LOOP-TOP)
(<span class="hljs-name">label</span> LOOP-DONE)
(<span class="hljs-name">half</span>)
</div></code></pre>
<h1 id="assembler-assignment">Assembler (assignment)</h1>
<p>2 Phases:</p>
<ol>
<li>Build a hash table of all symbols as keys. Values may not yet be known: <code>(const A B)</code>, <code>(const B 10)</code></li>
<li>Fill in the values - watch for the circular definitions</li>
</ol>
<pre><code class="language-lisp"><div>(<span class="hljs-name">const</span> A B)
(<span class="hljs-name">const</span> B C)
(<span class="hljs-name">const</span> C A)
</div></code></pre>
<ol start="3">
<li>Then produces the PRIMP program</li>
</ol>
<h2 id="converting-simp-into-a-primp-%22compiler%22">Converting SIMP into A-PRIMP (&quot;Compiler&quot;)</h2>
<p>Consider:</p>
<pre><code class="language-scheme"><div><span class="hljs-comment">;;SIMP:</span>
(<span class="hljs-name">vars</span> ([<span class="hljs-name">x</span> <span class="hljs-number">3</span>]) (<span class="hljs-name">print</span> x))

<span class="hljs-comment">;;A-PRIMP:</span>
(<span class="hljs-name">print-val</span> x)
(<span class="hljs-name">halt</span>)
(<span class="hljs-name">data</span> x <span class="hljs-number">3</span>)
</div></code></pre>
<p>Be careful about names: label names that compilers generate can never conflict with user defined names</p>
<p>Convention: Prefix SIMP vars with _</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">vars</span> [(<span class="hljs-name">x</span> <span class="hljs-number">3</span>)] (<span class="hljs-name">print</span> x))

<span class="hljs-comment">;Becomes</span>
(<span class="hljs-name">print-val</span> _x)
(<span class="hljs-name">halt</span>)
(<span class="hljs-name">data</span> _x <span class="hljs-number">3</span>)
</div></code></pre>
<p>In general:</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">vars</span> [(<span class="hljs-name">x1</span> n1) ... ] stmt ...)
<span class="hljs-comment">;; becomes</span>

<span class="hljs-comment">; STATEMENT CODE</span>
<span class="hljs-comment">;;-------</span>
(<span class="hljs-name">halt</span>)
<span class="hljs-comment">;;-------</span>
...
(<span class="hljs-name">data</span> _xi ni)
...
<span class="hljs-comment">;;-------</span>
<span class="hljs-comment">; Temporary Storage (forming a stack)</span>
</div></code></pre>
<p><strong>Why temp storage?</strong></p>
<p>Consider <code>(+ exp1 exp2)</code>. PRIMP can't do multiple things at a time. You need to recursively compute exp1, then exp2, then add them. you need to store the value of exp1 and exp2 somewhere. After you've computed the two values, you don't need the two temp variables anymore.</p>
<p>You could just create a separate location for every possible temporary. This doesn't generalize well. Adding functions and recursion to SIMP would compeltely break this. Temp vars in a funciton can't all use the same locations. Let's just use a stack.</p>
<p>Use a data stmt to create a var SP (stack pointer) that holds the location of the first unused spot in the stack.</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">move</span> SP <span class="hljs-number">5</span>)<span class="hljs-comment">; Stores 5 in SP, not on the stack</span>
(<span class="hljs-name">move</span> (<span class="hljs-name">SP</span>) <span class="hljs-number">5</span>)<span class="hljs-comment">; Not currently legal</span>
</div></code></pre>
<p>What if we want to fetch a vlue?</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">move</span> (<span class="hljs-name">A</span>) (<span class="hljs-name">-1</span> SP)) <span class="hljs-comment">; Not currently legal</span>
(<span class="hljs-name">move</span> (<span class="hljs-name">A</span>) (<span class="hljs-name">-2</span> SP))
</div></code></pre>
<p>We're going to cheat a little - Add to PRIMP.</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">OFFSET</span> LABEL) := M[<span class="hljs-name">OFFSET</span>] + M[<span class="hljs-name">LABEL</span>] <span class="hljs-comment">; Pointer access</span>
</div></code></pre>
<p>eg:</p>
<pre><code class="language-scheme"><div><span class="hljs-comment">; fetch the top of the stack:</span>
(<span class="hljs-name">add</span> (<span class="hljs-name">10</span> (<span class="hljs-name">-1</span> (<span class="hljs-name">59</span>)) <span class="hljs-number">1</span>))
<span class="hljs-comment">; equivalent to M[10] &lt;- M[-1 + M[59]] + 1 </span>
<span class="hljs-comment">; where SP = 59</span>

<span class="hljs-comment">; replace the top stack item with 0:</span>
(<span class="hljs-name">move</span> (<span class="hljs-name">-1</span> (<span class="hljs-name">59</span>)) <span class="hljs-number">0</span>) 

<span class="hljs-comment">; To push 0:</span>
(<span class="hljs-name">move</span> (<span class="hljs-name">0</span> (<span class="hljs-name">59</span>)) <span class="hljs-number">0</span>)
(<span class="hljs-name">add</span> (<span class="hljs-name">59</span>) (<span class="hljs-name">59</span>) <span class="hljs-number">1</span>))

Using SP:
(<span class="hljs-name">move</span> (<span class="hljs-name">0</span> SP) <span class="hljs-number">0</span>)
(<span class="hljs-name">add</span> SP SP <span class="hljs-number">1</span>)
</div></code></pre>
<p>To compile <code>(set var exp)</code></p>
<ol>
<li>Compile the code to execute exp</li>
<li>Code that pops the value on the top of the stack, moves it to the location associated with var.</li>
</ol>
<ul>
<li>dest is top of stack?</li>
<li></li>
</ul>
<pre><code class="language-scheme"><div>(<span class="hljs-name">iif</span> exp stmt1 stmt2)
=&gt;  exp-code
    (<span class="hljs-name">branch</span> dest LABEL0)
    (<span class="hljs-name">jump</span> LABEL1)

    (<span class="hljs-name">label</span> LABEL0)
    stmt<span class="hljs-number">1</span>-code
    (<span class="hljs-name">jump</span> LABEL2)

    (<span class="hljs-name">label</span> LABEL1)
    stmt<span class="hljs-number">2</span>-code
    (<span class="hljs-name">label</span> LABEL2)

(<span class="hljs-name">while</span> exp stmt1)
=&gt;  (<span class="hljs-name">label</span> LABEL0)
    exp-code
    (<span class="hljs-name">branch</span> dest LABEL1)
    (<span class="hljs-name">jump</span> LABEL2)
    (<span class="hljs-name">label</span> LABEL1)

    stmts-code

    (<span class="hljs-name">jump</span> LABEL0
    (<span class="hljs-name">label</span> LABEL2)

<span class="hljs-comment">;; The rest is the assignment</span>
</div></code></pre>
<h1 id="c-strings">C Strings</h1>
<p>C has no string type - strings in c are arrays of characters.</p>
<pre><code class="language-c"><div><span class="hljs-keyword">char</span> myString[] = <span class="hljs-string">"Hello"</span>;
</div></code></pre>
<p>Size of an array is not stored, arrays are passed as pointers.</p>
<p>Char arrays that denote strings end with the caracter <code>\0</code> (ASCII 0) that signals the end of the string.</p>
<pre><code class="language-c"><div><span class="hljs-keyword">char</span> myString[] = <span class="hljs-string">"Hello"</span> = [<span class="hljs-string">'H'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'\0'</span>]
sizoef(mystring) = <span class="hljs-number">6</span>;


<span class="hljs-comment">//Careful: </span>

<span class="hljs-keyword">char</span> *yourString = <span class="hljs-string">"Hello"</span>;
<span class="hljs-keyword">sizeof</span>(yourString) = <span class="hljs-number">8</span> <span class="hljs-comment">//(pointer)</span>
</div></code></pre>
<p>Is this on the heap? (no) Where is hello stored?</p>
<ul>
<li>Stored in the static area - &quot;Literal pool&quot;</li>
<li>Often read only memory</li>
<li></li>
</ul>
<pre><code class="language-c"><div>mystring[<span class="hljs-number">0</span>] = <span class="hljs-string">'h'</span> <span class="hljs-comment">// fine</span>
yourString[<span class="hljs-number">0</span>] = <span class="hljs-string">'h'</span>; <span class="hljs-comment">// undefined behaviour</span>
</div></code></pre>
<p>Printing strings: <code>printf(myString);</code> is fine unless you have percent signs etc.</p>
<p>`printf(&quot;%s&quot;, myString)</p>
<p>Keeps printing chars from myString until it hits \0 (not printed)</p>
<h2 id="string-manipulation">String Manipulation</h2>
<pre><code class="language-c"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">char</span> s[] = <span class="hljs-string">"Hello World"</span>
    <span class="hljs-keyword">char</span> t[<span class="hljs-number">12</span>];
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, <span class="hljs-built_in">strlen</span>(s));
    <span class="hljs-built_in">strcpy</span>(t, s);

    <span class="hljs-keyword">char</span> s[<span class="hljs-number">14</span>] = <span class="hljs-string">"Hello "</span>;
    <span class="hljs-built_in">strcat</span>(s, <span class="hljs-string">"world"</span>); <span class="hljs-comment">// concatenate</span>
    <span class="hljs-comment">// note c doesn't check size of s or t</span>
}

<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">strlen</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s){
    <span class="hljs-keyword">size_t</span> n = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (*s++) ++n;
    <span class="hljs-keyword">return</span> n;
}

<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *target, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *source)</span></span>{
    <span class="hljs-keyword">char</span> *result = target;
    <span class="hljs-keyword">while</span> (*target++ = *source++);
    <span class="hljs-keyword">return</span> result;    
}
</div></code></pre>
<h3 id="comparing-strings">Comparing Strings:</h3>
<pre><code class="language-c"><div>Char *s;
...
<span class="hljs-keyword">if</span> (s == <span class="hljs-string">"Hello"</span>){ ... } <span class="hljs-comment">// Comparing two pointers - not the same as checking if the strings are equal</span>

<span class="hljs-keyword">if</span> (!strmp(s, <span class="hljs-string">"hello"</span>)) {...} <span class="hljs-comment">// Good! </span>
</div></code></pre>
<p><code>stcmp(s,t)</code> returns:</p>
<ul>
<li><code>0</code> if <code>s == t</code>,</li>
<li><code>neg #</code> if <code>s &lt; t</code></li>
<li><code>pos #</code> if <code>s &gt; t</code></li>
</ul>
<p>Uses <strong>Lexicographic</strong> Order</p>
<p><code>strcpy, strcat</code> - make sure the target string holds enough space, as these do not allocate space</p>
<p>Consider: <code>char s[7] = abc; // 'a' 'b' 'c' '\0&quot;</code></p>
<p><code>strcpy(s + 3, s)</code>. Bad - runs forever. <code>strcpy(s+3, &quot;abc&quot;)</code> works fine.</p>
<h3 id="reading-strings">Reading Strings:</h3>
<pre><code class="language-c"><div><span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"What is your name?"</span>);
<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, name);
</div></code></pre>
<p>What if you type more than 20 characters? <strong>Buffer overflow</strong>! So just never use <code>scanf</code> with <code>%s</code>. Instead, <code>scanf(&quot;%19s&quot;, name);</code>. Scanf can only read in 19 characters (safer)</p>
<p>There's also a safer <code>strcpy</code>, <code>strcat</code>:</p>
<ul>
<li><code>strncpy(target, source, n);</code>
<ul>
<li>Copies untill <code>\0</code> or until <code>n</code> chars have been copied.</li>
</ul>
</li>
<li><code>strncat</code>, <code>strncmp</code></li>
<li><strong>Note</strong>: If <code>strncpy</code> stops because n characters have been copied, (ie: source is longer than n), no <code>\0</code> is added.</li>
</ul>
<p>eg:</p>
<pre><code class="language-c"><div><span class="hljs-built_in">strncpy</span>(target, source, <span class="hljs-number">10</span>);
target[<span class="hljs-number">10</span>] = <span class="hljs-number">0</span>;
</div></code></pre>
<p>Careful:</p>
<pre><code class="language-c"><div><span class="hljs-keyword">char</span> msg[<span class="hljs-number">6</span>] = <span class="hljs-string">"Hello"</span>; <span class="hljs-comment">//'H', 'e', 'l', 'l', 'o' ,'\0'</span>
<span class="hljs-keyword">char</span> msg[<span class="hljs-number">15</span>] = <span class="hljs-string">"Hello"</span>; <span class="hljs-comment">//'H', 'e', 'l', 'l', 'o' ,'\0', '\0', '\0', ...</span>
<span class="hljs-keyword">char</span> msg[<span class="hljs-number">5</span>] = <span class="hljs-string">"Hello"</span>; <span class="hljs-comment">//'H', 'e', 'l', 'l', 'o' - no null terminator</span>
<span class="hljs-keyword">char</span> msg[<span class="hljs-number">3</span>] = <span class="hljs-string">"Hello"</span>; <span class="hljs-comment">//'H', 'e', 'l' - truncated (warning), no null terminator</span>
</div></code></pre>
<h1 id="adding-functions-to-simp-simp-f">Adding Functions to SIMP (SIMP-F)</h1>
<p>Inventing new syntax:</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">fun</span> (<span class="hljs-name">f</span> x y)
    (<span class="hljs-name">vars</span> [(<span class="hljs-name">i</span> <span class="hljs-number">10</span>) (<span class="hljs-name">j</span> <span class="hljs-number">10</span>)]
        (<span class="hljs-name">set</span> i (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> j x) y))
        (<span class="hljs-name">return</span> (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> i i))))
</div></code></pre>
<p>Let's call this <strong>SIMP_F</strong>. Now that we have function, we might as well distinguish the function <code>main</code> (no parameters) which starts the program. How do we compile this in PRIMP? The problem is the return - Where do you go back to? The value of <code>pc</code> should be the very next line when you come back. We need to save pc somewhere, and store it somewhere for when we need to return.</p>
<p>No current PRIMP instruction lets you save pc. Let's add something new.</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name">jsr</span> (<span class="hljs-name">50</span>) <span class="hljs-number">10</span>) <span class="hljs-comment">;; Jump to sub routine</span>
</div></code></pre>
<p>`(jsr (50) 10) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span></span></span></span> M[50] <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">←</span></span></span></span> PC; PC <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">←</span></span></span></span> 10</p>
<h1 id="module-4-mmix">Module 4: MMIX</h1>
<p>Binary 1/0 instructions are dependent on chip. What language do we use?</p>
<p>Primp is unrealisitc. Locations are a fixed size (32 or 64 bits) and no matter what value the PRIMP vector location holds, (number, instr, etc) it has to fit in 32 bits.</p>
<ul>
<li>Encoding scheme for #s</li>
<li>Encoding scheme for instructions</li>
<li>Note these two will overlap. The only way to tell what the word represents is by context</li>
</ul>
<p>Terminology:</p>
<p>Address 8</p>
<table>
<thead>
<tr>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
</tr>
</thead>
<tbody>
<tr>
<td>1100110</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>Most significant bit</td>
<td></td>
<td></td>
<td></td>
<td>Least significant bit</td>
</tr>
</tbody>
</table>
<p>Bits are grouped into 8 bytes of 8 bits each (7:0) - LSB and (63:56) - MSB</p>
<ul>
<li>Each byte has an address.</li>
<li>The atddres of a word is the address of it's most significant byte. Addresses increase left to right. (Big indian architecture)</li>
</ul>
<p>Negtive Numbers: 2's compliment notation</p>
<ul>
<li>If the first bit is 1, is it negative or a large positive? You chose.</li>
</ul>
<p><code>int x: -2^31 ... 2^31 - 1</code></p>
<p><code>unsigned int x: 0 ... 2^32 - 1</code></p>
<p><strong>Why PRIMP isn't realistic</strong></p>
<ul>
<li>Large memories are slow</li>
<li>Most instructions run in 1-2 clock cycles</li>
<li>Memory accesses can take 10s or 100s of cycles</li>
<li>Makes sense to have a small amount of fast memory (Registers) to do computations on that</li>
<li>Move to and from main memory when necessary</li>
</ul>
<h2 id="mmix-machine">MMIX Machine</h2>
<p>General Purpose Registers</p>
<ul>
<li>$0 to $255</li>
<li>64 bits wide</li>
</ul>
<p>Special purpose registers</p>
<ul>
<li>rA, rB, ... rZ, rZZ</li>
<li>64 bits wide</li>
<li>Normally works with the actual running of the hardware</li>
</ul>
<p>Ram</p>
<ul>
<li>M[0] ... M[2^64 - 8]</li>
<li>64 bits wide</li>
</ul>
<p>Example MMIX instruction (instructions are 32 bits wide)</p>
<pre><code><div>ADD $4, $3, $2    -- Set $4 to $3 + $2
</div></code></pre>
<p>This uses hex encoding: 0x20 04 03 02</p>
<h2 id="data-processing-instructions">Data processing instructions</h2>
<pre><code><div>Register format: | Opcode | Dest reg | src reg1 | src reg2| (all size 8)
eg: ADD $A, $B, $C

Immediate format: | Opcode | Dest reg | src reg1 | src reg2| (all size 8)
eg: ADD $A, $B, V
</div></code></pre>
<p>Note this still isn't the binary</p>
<p>Add in register format will have a different Opcode to Immediate. (register = 20, immediate = 21). Immediate format opcode is the immediate format opcode + 1</p>
<p>eg:</p>
<pre><code><div>ADD (reg) opcode = 0x20
ADD (imm) opcode = 0x21

SUB 0x24
MUL 0x18
DIV 0x1c

DIV $x, $y, $z
sets $X &lt;- floor($y / $z)
sets rR &lt;- $Y mod $z

fetch from rR:
0xFE GET $x, rR --  gets $x, Z .Fetch from special reg
</div></code></pre>
<p>Comparisons</p>
<pre><code><div>0x30 CMP $X, $Y, $Z
$X is -1 if $Y &lt; $Z
      0 if $Y = $Z
      1 if $Y &gt; $Z

Branches and jumps:

IMP Addr (24 bits) --  @+=Addr *4

-- @ is the PC, += is relative counting

BN $X, Addr     -- @+=Addr *4 if $x &lt; 0 (N means negative)

Also:

BZ - Zero
BP - Positive
BOD - OddB
BNN - Non neg
BNZ - Non zero
DNP - non pos
BEV - even
</div></code></pre>

    </body>
    </html>