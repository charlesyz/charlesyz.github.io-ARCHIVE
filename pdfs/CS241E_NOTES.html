<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>05/09/2019 Intro</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body>
        <h1 id="05092019-intro">05/09/2019 Intro</h1>
<p>What are programs made of?</p>
<ul>
<li>Objects</li>
<li>Functions</li>
<li>Statements, control structures</li>
<li>Expressions</li>
<li>Instructions</li>
<li>Bits</li>
</ul>
<p>These are all abstractions
use theory proofs to build up. start from bits, machine language</p>
<p>CS360/5, 462 are more theory stuff</p>
<p>Tutorials are assignment times (optionalish)</p>
<h1 id="05092019">05/09/2019</h1>
<p><code>100 0011</code>
What does this mean? Nothing until we know how to interpret
maybe: 67, c, -3, 61
It can be natural numbers, integers, characters, images, sounds, video ...</p>
<p>we use <code>Zmod32</code>. <code>-1 = 2^32 - 1 mod 2^32</code></p>
<h1 id="10092019">10/09/2019</h1>
<h2 id="2s-comp--numbers">2s comp / Numbers</h2>
<p>Reminder 1000011 represents every number <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≡</mo><mn>67</mn><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><msup><mn>2</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">\equiv 67 \mod 2^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">7</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span> (7 bits)</p>
<p>Note this means we have the same hardware for +, -, *</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>67</mn><mo>≡</mo><mo>−</mo><mn>61</mn></mrow><annotation encoding="application/x-tex">67 \equiv -61</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">6</span><span class="mord">1</span></span></span></span>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>67</mn><mo>+</mo><mn>42</mn><mo>≡</mo><mo>−</mo><mn>61</mn><mo>+</mo><mn>42</mn></mrow><annotation encoding="application/x-tex">67 + 42 \equiv -61 + 42</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">6</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">2</span></span></span></span></p>
<p>Note we need separate hardware for /, &lt;, &gt;</p>
<p>Ranges:</p>
<p>0 -&gt; 2^32 - 1 = Unsigned Numbers
-2^31 -&gt; 2^31-1 = Two's compliment</p>
<p>Essentially, take the first bit and make it negative</p>
<p>unsigned 1000011 = 2^6 + 2^1 + 2^0 = 67
2s comp  1000011 = (-2^6) = 2^1 + 2^0 = -61</p>
<h2 id="the-machine">The Machine</h2>
<p><strong>Memory</strong>:</p>
<p>Big 2d array of bits: 32 bits wide, 2^22 bits tall
One row (32 bits is a word)</p>
<pre><code><div>0100...
12..
..
.
</div></code></pre>
<p>We need a circuit to flip bits!</p>
<p><strong>Processor</strong>:</p>
<p>Add a bit of memory in the processor (32 bits x 34 bits) - Registers
Need a control unit and an Arithmetic Logic Unit (ALU) for math</p>
<p>Registers are 1...31, LO HI PC
Memory are numbered 0,4,8,12,...2^24-4</p>
<p><strong>Def:</strong> A slowed-program computer (von Neumann machine) includes program to be executed as part of input - code is data</p>
<p><code>Function step : State -&gt; State</code></p>
<p>State = {0, 1}^32 * 24 + 2^7</p>
<p>We need a pointer to where our program is currently at -&gt; the Program Counter (PC)</p>
<pre><code class="language-scala"><div>step(<span class="hljs-type">State</span>) = {
    let instruction = state, mem(state.reg(<span class="hljs-type">PC</span>))
    let state2 = state.setReg(<span class="hljs-type">PC</span>, state.reg(<span class="hljs-type">PC</span>) + <span class="hljs-number">4</span>)
    instruction <span class="hljs-keyword">match</span> {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0110</span> ... =&gt; let newState = ... state2 ...
            <span class="hljs-keyword">return</span> newState
            ..
    }
}
</div></code></pre>
<p>Register 31 has the termination counter
Max address is at register 30</p>
<h1 id="12092019">12/09/2019</h1>
<p><strong>Def:</strong> an <em>opcode</em> is a word that represents a machine language instruciton (ADD, JR...)
<strong>Def:</strong> <em>Assembly Language</em> is a language for writing machine language programs with opcodes and labels
<strong>Def:</strong> an <em>Assembler</em> is a program that translates assembly language to machine language</p>
<p>Ex: Find 2 s compliment of number in $1</p>
<pre><code class="language-scala"><div><span class="hljs-type">SLT</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// $1 &lt; 0</span>
<span class="hljs-type">BEQ</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// skip the next line if $2==0</span>
<span class="hljs-type">SUB</span> (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 0 - $1</span>
<span class="hljs-type">JR</span>(<span class="hljs-number">31</span>)
</div></code></pre>
<p>Note we can use labels:</p>
<pre><code class="language-scala"><div><span class="hljs-keyword">val</span> label = <span class="hljs-keyword">new</span> <span class="hljs-type">Label</span>(<span class="hljs-string">"label"</span>)
<span class="hljs-type">Seq</span>(
    <span class="hljs-type">SLT</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-comment">// $1 &lt; 0</span>
    beq(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, label), <span class="hljs-comment">// skip the next line if $2== 0 Lower case to distinguish from BEQ</span>
    <span class="hljs-type">SUB</span> (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), <span class="hljs-comment">// 0 - $1</span>
    <span class="hljs-type">Define</span>(label),
    <span class="hljs-type">JR</span>(<span class="hljs-number">31</span>)
)
</div></code></pre>
<p><strong>Def:</strong> a <em>Label</em> is an abstraction of a memory address</p>
<p>note Define() doesn't correspond to a Word. What is it?</p>
<p>Before, our program was a Seq[Word]. Now, it's a Seq[Code].
Code can be: Word, Define ... (add more later)</p>
<p>Assembler:
eliminate Labels, replaces with actual address</p>
<p>Branch with label can't be represented with a word until we resolve the label.</p>
<p><strong>Eliminating Labels</strong>
Two passes:</p>
<ol>
<li>Determin address of each label (build symbol table)</li>
<li>Convert uses of each label to addresses (use symbol table)</li>
</ol>
<table>
<thead>
<tr>
<th>label</th>
<th>address</th>
</tr>
</thead>
<tbody>
<tr>
<td>label</td>
<td>12</td>
</tr>
</tbody>
</table>
<p><strong>Def</strong>: a <em>Symbol Table</em> is a map of names(of labels) to memory addresses</p>
<p><strong>Def</strong>: a Block is a set of statements</p>
<pre><code><div>Define(p)
...
JR(31) //Return to orig PC
</div></code></pre>
<p>If i want to call the code defined under p, branch to p and store PC (<code>JALR(7)</code>)</p>
<p>JALR -&gt;</p>
<ul>
<li>PC &lt;- $7</li>
<li>$31 &lt;- PC</li>
</ul>
<p>Note: $31 got overwritten. Also, if we nest procedures, we won't know where to return to.</p>
<h1 id="17092019">17/09/2019</h1>
<p>Relocation + Linking</p>
<pre><code><div>0: lis $1
4: 100 (in binary) 
8: Use(p)
8: jalr $1

-- next file

0: Define(p)
4: lis $1
8: Use(e)
12: jr $1
16: Define(e)
20: jr $31

Assemble first block:

0: lis $1
4: 0 // ???
8: jalr $1

(use p @ 4)

Assemble after define p: (imagine it starts at 0)

0: lis $1
4: 12
8: jr $1
12: jr $31

(p -&gt; 0, e -&gt; 12, use(e) at 4)

Then, link the two above object files:

0: lis $1
4: 0 // ???
8: jalr $1
12: lis $1
16: 12
20: jr $1
24: jr $31

</div></code></pre>
<p>Sym table:</p>
<table>
<thead>
<tr>
<th>label</th>
<th>addr</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>100</td>
</tr>
</tbody>
</table>
<p><strong>Def:</strong> An object file contains machine language with metadata that records where labels were defined / used
<strong>Def:</strong> Linking is the process of combining object files into one program or library
<strong>Def:</strong> Relocation is the process of adjusting addresses in machine language code so it can be loaded at a different</p>
<p>Linking has two steps: Relocation and resolving labels (match Use with Define)</p>
<h2 id="variables-assignment-3">Variables (assignment 3)</h2>
<p><strong>Def:</strong> A variable is an abstraction of a storage location (memory or register) that can store a value</p>
<p>Variable instance:</p>
<p>eg:</p>
<pre><code class="language-scala"><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fact</span></span>(x:<span class="hljs-type">Int</span>) : <span class="hljs-type">Int</span> = <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> x * fact(x<span class="hljs-number">-1</span>)
fact(<span class="hljs-number">3</span>)
</div></code></pre>
<p>What value does x have during the program runtime?
x = 3, x = 2, x = 1
But, we can't change x in each recursive call since the function is not tail recursive</p>
<p><strong>Def:</strong>  the Extent of a variable instance is the time interval in which the variable can be accessed</p>
<table>
<thead>
<tr>
<th>Variable Kind</th>
<th>extent</th>
<th>Implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td>global</td>
<td>Entire program execution</td>
<td>Fixed address</td>
</tr>
<tr>
<td>Procedure-local</td>
<td>execution of the proc. instance</td>
<td>Stack</td>
</tr>
<tr>
<td>field of an object/record/cons cell</td>
<td>from the time the object is created to hte last time it's used</td>
<td>Heap</td>
</tr>
</tbody>
</table>
<p>To implement a stack:</p>
<p>Designate a variable (register) to hold the address of the top of the stack (stack pointer)</p>
<ul>
<li>Push: decrement SP by 4</li>
<li>Pop: increment SP by 4</li>
</ul>
<p>We will use $30 as the SP</p>
<h2 id="program">Program</h2>
<h2 id="topstack">(Top)
Stack</h2>
<h1 id="19092019">19/09/2019</h1>
<p><strong>Variables stack</strong></p>
<p>Stack pointer $30</p>
<p>ex $30 = 100</p>
<p>reg(30)
use <strong>reg.stackPointer</strong></p>
<pre><code><div>$30 = 100 = a
      104 = b
      108 = c
</div></code></pre>
<p>eg: read the value of c into $3</p>
<pre><code class="language-scala"><div><span class="hljs-type">LW</span>(<span class="hljs-type">Reg</span>(<span class="hljs-number">3</span>), <span class="hljs-number">8</span>,<span class="hljs-type">Reg</span>.sp)
</div></code></pre>
<p>or, <code>Reg(3) = Reg.result</code></p>
<p>You can see that the compiler needs a symbol table of offsets</p>
<p><strong>Def:</strong> a <em>frame pointer</em> is a copy of a stack pointer made at the start of the procedure that does not change for the duration of hte procedure call. MIPS convention: $29 - frame pointer</p>
<p>In assignments, all memory organized in chunks</p>
<ul>
<li>Always push / pop one chunk at a time</li>
</ul>
<pre><code><div>----
size
A11 
a
b
c
---
</div></code></pre>
<h2 id="evaluating-expressions">Evaluating Expressions</h2>
<p><code>(A*B) + (C*D)</code></p>
<p>Generate machine language from AST</p>
<p><strong>Technique 1</strong></p>
<ul>
<li>Generate code to evaluate e1 op e2 and put result in register.result $3</li>
<li>Push it to the stack</li>
</ul>
<pre><code class="language-scala"><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate</span></span>(e, op, e2) : <span class="hljs-type">Code</span> = block(
    evaluate(e1)
    <span class="hljs-comment">// need two different places for e1, e2</span>
    push $<span class="hljs-number">3</span>
    evaluate(e2)
    pop $<span class="hljs-number">4</span>
    $<span class="hljs-number">3</span> = $<span class="hljs-number">4</span> op $<span class="hljs-number">3</span>
)
</div></code></pre>
<p><strong>Technique 2</strong></p>
<ul>
<li>Use variables</li>
</ul>
<p>// gen code to evaluate e1 op e2 and put result in a variable</p>
<pre><code class="language-scala"><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate</span></span>(eq op e2) : (<span class="hljs-type">Code</span>, variable) = {
    <span class="hljs-keyword">val</span> (c1, v1) = evaluate(e1)
    <span class="hljs-keyword">val</span> (c2, v2) = evaluate(e2)
    v3 = <span class="hljs-keyword">new</span> <span class="hljs-type">Variable</span>(<span class="hljs-string">"v3"</span>)
    <span class="hljs-keyword">val</span> code = c1 ++ c2  :+ (v3 = v1 op v2)
    (code, v3)
}
</div></code></pre>
<p>Good: flexible, correct
Bad: Uses a lot of variables. Note with this approach you need to define v1 op v2 for each operation. No machine language that operates on variables.</p>
<p>Note this is easy to optimize later</p>
<p>Notes:
difference between stack pointer and frame pointer. SP - top of stack. FP - current recursive pointer. Within a procedure, offset must stay constant.</p>
<p><strong>Def:</strong> Register allocation is the process of assigning variables to registers as memory/stack locations.</p>
<p><strong>Technique 3</strong> : C variables, but arithmetic on registers. (A4)
// ge code to eval e1 op e2, put result in $3.</p>
<pre><code class="language-scala"><div>evaluate(e1 op e2) : code = {
    t1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Variable</span>
    <span class="hljs-type">Scope</span>(t1, 
    block(
        evaluate(e1)
        write(t1,$<span class="hljs-number">3</span>)
        evaluate(e2)
        read(t1, $<span class="hljs-number">4</span>)
        $<span class="hljs-number">3</span> = $<span class="hljs-number">4</span> op $<span class="hljs-number">3</span>))
}
</div></code></pre>
<p>Note we need a list of all variables used.</p>
<p>New code: Scope, with variables and code</p>
<ul>
<li>contains variables and code</li>
<li>keeps track of variables we use</li>
</ul>
<p><strong>Control (if, while)</strong></p>
<p><code>if (e1 op e2) T else E</code></p>
<ul>
<li><code>if (1 &lt; 2 )...</code></li>
<li><code>if (a + b &gt;= c + d ) ...</code></li>
</ul>
<pre><code class="language-scala"><div>evaluate(e1)
t1 = $<span class="hljs-number">3</span>
evaluate(e2)
$<span class="hljs-number">4</span> = t1
op, beq/bne label (branch <span class="hljs-keyword">if</span> <span class="hljs-literal">false</span>)
<span class="hljs-type">T</span>
beq/jr endLabel
<span class="hljs-type">Define</span>(label)
<span class="hljs-type">E</span>
<span class="hljs-type">Define</span>(endLabel)
</div></code></pre>
<h1 id="26092019">26/09/2019</h1>
<p>Arrays:</p>
<ul>
<li>contiguous area of memory</li>
<li>each index at offset from starting address</li>
</ul>
<p>starting address:</p>
<table>
<thead>
<tr>
<th>addr</th>
<th>mem</th>
</tr>
</thead>
<tbody>
<tr>
<td>startingaddress</td>
<td>A[0]</td>
</tr>
<tr>
<td>startingaddress + 4*i</td>
<td>A[1]</td>
</tr>
<tr>
<td>...</td>
<td>A[2]</td>
</tr>
<tr>
<td>...</td>
<td>A[3]</td>
</tr>
</tbody>
</table>
<p>Register allocation maps variables to registers or memory locations / stack offsets.</p>
<p>Want to maximize speed, #variables you can put in the registers.</p>
<p><strong>Def:</strong> A variable is life at a program point p if the value that it holds at p may be read sometime after p.</p>
<p><strong>Def:</strong> Interference graph
vertexes: variables
edges: Connect paris of vars live at a program point</p>
<p><strong>Def:</strong> a <strong>colouring</strong> assigns a colour to each vertex s.t. each edge connects vertices with distinct colours</p>
<p>colours: registers
colouring: rgisters, assignments</p>
<p>Finding minimal graph colouring is NP hard.
Simple greedy is good enough for now.</p>
<pre><code><div>for each vector v {
    colour v with least colour not used by it's neighbours
}
</div></code></pre>
<p>What if we need too many colours? (&gt;30), assign to stack offsets</p>
<h1 id="01102019-procedures">01/10/2019 Procedures</h1>
<p>Procedure: an abstraciton that encapsultes reusable sequences of code</p>
<ul>
<li>caller transfers control to the callee(modifies PC)</li>
<li>callee returns back to caller</li>
<li>local variables</li>
<li>pass parameters from caller to callee</li>
<li>callee returns a value to caller</li>
</ul>
<pre><code class="language-sc"><div># Callee

Define(proc)
Reg.savedParamPtr = Reg.result
Stack.allocate(frame)
dynamicLink = Reg.fp            # base register is reg.result
savedPC = Reg.link
Reg.fp = Reg.result ($29  = $3)
paramPtr = Reg.savedParamPtr

CODE

Reg.link = savedPC
Reg.fp = dynamicLink
Stack.pop // frame
Stack.pop // params
JR(Reg.link) ($31)

| callee frame  |
|---------------|
|     alloc     | &lt;- FP
|   Variables   |
| Dynamic Link  | -&gt; points to frame of the caller
| ...           |
| saved         |
| reg $5        |
| size          |
| param ptr     | -&gt; points to result $5
| result $5     |
| A11           |
|---------------|
| Caller frame  |
|---------------|

# Caller

# might require other function calls so do it here.
# other f calls might change reg.result, etc.
evaluate args into temp variables
stack.allocate(params)
copy args from temp vars into vars in the param chunk

LIS(Reg.targetPC)
Use(proc)
JALR(Reg.targetPC) # Call the function
</div></code></pre>
<h2 id="cs241e-conventions">CS241E Conventions:</h2>
<p>Caller and Callee need to agree on coventions</p>
<ul>
<li>Which registers can be modified by the call</li>
</ul>
<p>caller-save:
if you think this is important save it first</p>
<p>| Caller-save   | Callee-save  |</p>
<table>
<thead>
<tr>
<th>(modified)</th>
<th>(preserved)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$31</code> Reg link</td>
<td><code>$30</code> Reg.sp</td>
</tr>
<tr>
<td><code>$4</code> Reg.result</td>
<td><code>$29</code> Reg.fp</td>
</tr>
</tbody>
</table>
<p>callee can modify | callee can't modify</p>
<p>Who allocates and saves memory?</p>
<ul>
<li>Callee allocates and frees frame for variables.</li>
</ul>
<p>Where to pass paramters and return value?</p>
<ul>
<li>Parameters in a chunk who's address is in <code>$3</code> reg.result8</li>
<li>Return in Reg.result</li>
</ul>
<p>A3: Always use frame pointer as base register</p>
<h1 id="03102019">03/10/2019</h1>
<p><strong>Def:</strong> Prologue/epilogue
is the code at the beginning and end of every function
<strong>Def:</strong> Dynamic Link
pointer to the frame of the procedure that called the currently executing procedure</p>
<pre><code class="language-scala"><div>eliminateVarAccesses(<span class="hljs-type">A5</span>){
    <span class="hljs-keyword">if</span> v is not a parameter (variable)
        access v in frame (<span class="hljs-type">A3</span>)
    <span class="hljs-keyword">else</span> <span class="hljs-comment">// parameter</span>
        read parameter from frame into <span class="hljs-type">Reg</span>.scratch
        access(v or w) v in parameter chunk
}
</div></code></pre>
<h2 id="assignment-6">Assignment 6</h2>
<p>Nested procedures:</p>
<pre><code class="language-scala"><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span></span>() = {
    <span class="hljs-keyword">val</span> x = <span class="hljs-number">2</span>
    <span class="hljs-keyword">val</span> w = <span class="hljs-number">5</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span></span>(x) = {
        <span class="hljs-keyword">val</span> y = <span class="hljs-number">3</span>
        <span class="hljs-keyword">val</span> w = <span class="hljs-number">7</span>
        x + y + h()
    }
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">h</span></span>() = {
        <span class="hljs-keyword">val</span> z = <span class="hljs-number">4</span>
        z + w
    }

    g()
}
</div></code></pre>
<p>What does this return? 14? 16?</p>
<p>Static (lexical) scope : h uses f's w. names resolved in statically enclosing procedures
Dynamic scope: h uses g's w. Names resolved in dynamically (execution) calling procedures</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>H's frame</td>
</tr>
<tr>
<td>z</td>
</tr>
<tr>
<td>pp = h's ps</td>
</tr>
<tr>
<td>dl = g's frame</td>
</tr>
<tr>
<td>---------------</td>
</tr>
<tr>
<td>H's Parameters</td>
</tr>
<tr>
<td>---------------</td>
</tr>
<tr>
<td>G's frame</td>
</tr>
<tr>
<td>w 7</td>
</tr>
<tr>
<td>d 1</td>
</tr>
<tr>
<td>pp = g's ps</td>
</tr>
<tr>
<td>dl = f's frame</td>
</tr>
<tr>
<td>---------------</td>
</tr>
<tr>
<td>G's Parameters</td>
</tr>
<tr>
<td>---------------</td>
</tr>
<tr>
<td>F's Frame</td>
</tr>
<tr>
<td>w 7</td>
</tr>
<tr>
<td>pp = g's ps</td>
</tr>
<tr>
<td>---------------</td>
</tr>
<tr>
<td>F's paramters</td>
</tr>
</tbody>
</table>
<p>Turns out, no one actually uses dynamic scope</p>
<p>How do we use static scope?</p>
<p>Follow the dynamic pointer link twice? Use a static link</p>
<p><strong>Def:</strong> A Static Link is a pointer to the frame of hte statically enclosing procedure of the currently executing procedure
<strong>Def:</strong> Nesting depth of a procedure is the number of outer processes it is nested inside of</p>
<pre><code class="language-scala"><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eliminateVarAccessesA6</span></span>{ <span class="hljs-comment">//(access v)</span>
    let n = depth(currentProcedure) - depth(procedure declaring <span class="hljs-type">V</span>)
    <span class="hljs-type">Gen</span> code to follow static link n times, then access v in frame

    <span class="hljs-type">Each</span> procedure has a pointer to the preceeding procedure
    <span class="hljs-comment">// Trick: follow slink once (two loadwords), -&gt; pp and sl</span>
}
</div></code></pre>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>H's frame</td>
</tr>
<tr>
<td>z</td>
</tr>
<tr>
<td>pp = h's ps</td>
</tr>
<tr>
<td>dl = g's frame</td>
</tr>
<tr>
<td>---------------</td>
</tr>
<tr>
<td>H's Parameters</td>
</tr>
<tr>
<td>sl = f's frame</td>
</tr>
<tr>
<td>---------------</td>
</tr>
<tr>
<td>G's frame</td>
</tr>
<tr>
<td>w 7</td>
</tr>
<tr>
<td>d 1</td>
</tr>
<tr>
<td>pp = g's ps</td>
</tr>
<tr>
<td>dl = f's frame</td>
</tr>
<tr>
<td>---------------</td>
</tr>
<tr>
<td>G's Parameters</td>
</tr>
<tr>
<td>sl = f's frame</td>
</tr>
<tr>
<td>---------------</td>
</tr>
<tr>
<td>F's Frame</td>
</tr>
<tr>
<td>w 7</td>
</tr>
<tr>
<td>pp = g's ps</td>
</tr>
<tr>
<td>---------------</td>
</tr>
<tr>
<td>F's paramters</td>
</tr>
</tbody>
</table>
<h1 id="08102019">08/10/2019</h1>
<p><strong>Def:</strong> Static Link : Pointer to the frame of a statically enclosing procedure</p>
<p>To access variable v,
let n = depth(current proc) - depth(proc delaring v)
follow static link n times, then access v in that frame</p>
<p><strong>To compute static link at call site:</strong></p>
<pre><code><div>depth(SL (procedure who's frame the SL points to)) = depth(call target) - 1
Let n  = depth(current proc (caller)) - depth(static link)
       = depth(caller) - depth(callee) + 1

if n = 0,
   then the callee's sl is the caller's fp
else
    callee's sl = follow caller's sl n times
</div></code></pre>
<p><strong>Program</strong></p>
<pre><code class="language-sc"><div>f() {             // depth 0
    g() { h()}    // depth 1
    h() {         // depth 1
        k(){      // depth 2
            g()
        }
        k();
    }
}
</div></code></pre>
<p><strong>Execution</strong></p>
<pre><code><div>--------   &lt;- g's fp
paramPtr 
sl
--------   &lt;- k's fp
paramPtr 
sl
--------   &lt;- h's fp
paramPtr 
sl
--------   &lt;- g's fp
paramPtr 
sl
--------   &lt;- f's fp
f frame
params
</div></code></pre>
<p>For program above:</p>
<pre><code><div>f calls g (n = 0) g's SL = f's FP
g calls h (n = 1) h's SL = g's SL
h calls k (n = 0) k's SL = h's FP
k calls g (n = 2) g's SL = g's SL = f's FP
</div></code></pre>
<p><strong>Def:</strong> A <strong>Free Variable</strong> in an expression is a var that is not bounded / defined in the expression.
eg: Increment free in {x -&gt; x + increment}
x not free in {x -&gt; x + increment}
x is free in {x + increment{</p>
<p><strong>Def:</strong> An expression is closed if it has no free variables</p>

    </body>
    </html>